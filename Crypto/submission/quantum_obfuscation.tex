\documentclass[envcountsame]{llncs}
\usepackage{etex}
\usepackage{authblk}
\setcounter{tocdepth}{3}

\input{Qcircuit}
\usepackage{color}
\usepackage{amsmath,amsbsy,amssymb,dsfont}

\usepackage{mathtools}

\usepackage[pdfpagelabels, colorlinks=true,urlcolor=webblue,linkcolor=webgreen,filecolor=webblue,citecolor=webgreen,pdfpagemode=UseOutlines,pdfstartview=FitH,pdfpagelayout=OneColumn,bookmarks=true,hyperfootnotes=false]{hyperref}
%\usepackage{fullpage}
\usepackage{doi}
\usepackage[numbers]{natbib}
\usepackage{microtype}
\usepackage{xspace}
\usepackage{tikz}
\usepackage{bigints}
\usepackage{mathptmx}
%\usepackage{palatino}
\usepackage{eucal}
\usepackage[a4paper, margin=1in]{geometry}
\usepackage{cleveref}

\setcounter{secnumdepth}{3}
\pagestyle{plain}
%---pictures
%\usepackage{tikz}
\usepackage{tikz}
\usetikzlibrary{shapes, arrows, positioning}

\definecolor{webgreen}{rgb}{0,.5,0}
\definecolor{webblue}{rgb}{0,0,.5}

\DeclareMathOperator{\tr}{Tr}
\DeclareMathOperator*{\Exp}{\mathbb{E}}

\numberwithin{equation}{section}

%\newtheorem{theorem}{Theorem}
\newtheorem{prop}{Proposition}
%\newtheorem{proposition}{Proposition}
%\newtheorem{lemma}[theorem]{Lemma}
%\newtheorem{conjecture}{Conjecture}
%\newtheorem{claim}[theorem]{Claim}
%\newtheorem{corollary}[theorem]{Corollary}
%\newtheorem{definition}{Definition}
%\newtheorem{question}{Question}
%\newtheorem{problem}{Problem}

%% Define a satisfactory mathbb 1.
\newcommand{\one}{\mathds 1}
%\renewcommand{\vec}[1]{\mathbf{#1}}
\newcommand{\D}{\mathsf{D}}
\DeclareMathOperator{\Ind}{Ind}
\DeclareMathOperator{\End}{End}
\newcommand{\op}{\operatorname{op}}
\newcommand{\opn}{\operatorname}
\newcommand{\inter}{\mathfrak{I}}
\newcommand{\eqdef}{\triangleq}
\newcommand{\E}{\mathbb{E}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\U}{\textsf{U}}
\newcommand{\outerprod}[2]{|#1\rangle\langle #2|}
\newcommand{\innerprod}[2]{\langle #1, #2\rangle}
%\newcommand{\ket}[1]{|#1\rangle}
%\newcommand{\bra}[1]{\langle #1|}
\newcommand{\Hom}{\operatorname{Hom}}
\newcommand{\GL}{\textsf{GL}}
\newcommand{\SU}{\textsf{SU}}


\newcommand{\expref}[2]{\texorpdfstring{\hyperref[#2]{#1~\ref{#2}}}{#1~\ref{#2}}}
\newcommand{\expreft}[2]{\texorpdfstring{\hyperref[#2]{#1}}{#1}}

\newcommand{\revise}[1]{}
%\renewcommand{\vec}[1]{\mathbf{#1}}

\newcommand{\band}[1]{\mathcal{#1}}
\newcommand{\error}{\varepsilon}
\newcommand{\recon}{R}
\newcommand{\idim}{\dim_{\opn{I}}}

%%% added by GA  Sept 2015
\newcommand{\algo}{\mathcal}
\newcommand{\negl}{\opn{negl}}
\newcommand{\poly}{\opn{poly}}
\newcommand{\KeyGen}{\ensuremath{\mathsf{KeyGen}}\xspace}
\newcommand{\Enc}{\ensuremath{\mathsf{Enc}}\xspace}
\newcommand{\Dec}{\ensuremath{\mathsf{Dec}}\xspace}
\newcommand{\Homorcl}{\ensuremath{\mathsf{Hom}}\xspace}
\newcommand{\Mint}{\ensuremath{\mathsf{Mint}}\xspace}
\newcommand{\Verify}{\ensuremath{\mathsf{Verify}}\xspace}
\newcommand{\inrand}{\in_R} 
\newcommand{\prob}{\opn{Pr}}
\newcommand{\states}{\mathfrak D}
\newcommand\supp{\textbf{supp}}
\newcommand\Eval{\ensuremath{\mathsf{Eval}}\xspace}
%%%

\newcommand{\ga}[1]{{ \textcolor{purple}{(Gorjan:  #1)}}{}}
\newcommand{\wf}[1]{{ \textcolor{orange}{(Bill:  #1)}}{}}

\bibliographystyle{alpha}

\title{On Quantum Obfuscation}
\titlerunning{On Quantum Obfuscation}
\author{Gorjan Alagic \inst{1} Bill Fefferman \inst{2}}
\institute{QMATH, Department of Mathematical Sciences, University of Copenhagen\\
\email{galagic@gmail.com}
\and Joint Center for Quantum Information and Computer Science (QuICS), University of Maryland\\
\email{wjf@umd.edu}}
%\thanks{Department of Mathematical Sciences, University of Copenhagen. \textsf{galagic@gmail.com}}
%\qquad
%\thanks {Joint Center for Quantum Information and Computer Science (QuICS), University of Maryland. \textsf{wjf@umd.edu}}

\renewcommand\Authands{ and }

\begin{document}
\mainmatter

\toctitle{On Quantum Obfuscation}
%\tocauthor{Gorjan Alagic and Bill Fefferman}

\maketitle
\thispagestyle{plain}

\begin{abstract}
Program obfuscation is a powerful primitive in theoretical cryptography. While its most powerful incarnation (\emph{black-box obfuscation}) is impossible, a weaker variant (\emph{indistinguishability obfuscation}) appears to be possible and still quite useful. In this work, we initiate the rigorous study of obfuscating programs \emph{via quantum-mechanical means.} We define several notions of quantum obfuscation, based on various parameters. First, the input to the obfuscator can describe classical or quantum functionality, and the output can be a circuit description or a quantum state. Second, the obfuscator can satisfy one of a number of obfuscation conditions: black-box, indistinguishability, and best-possible. Finally, the last two conditions come in three variants: perfect, statistical, and computational. 

We discuss a number of applications, including quantum witness encryption and public-key quantum money. We then prove several impossibility results, extending a number of basic results on classical obfuscation to the quantum setting. We prove that quantum black-box obfuscation is impossible in a setting where adversaries can possess more than one output of the obfuscator (possibly even on the same input.) In particular, generic transformation of quantum circuits into black-box-obfuscated quantum circuits is impossible. We also show that statistical indistinguishability obfuscation is impossible, up to a standard complexity-theoretic conjecture. Our proofs require a new tool: non-adaptive chosen-ciphertext-secure encryption of quantum data~\cite{ABFGSS16}. 

We emphasize that our results leave open an intriguing possibility: black-box obfuscation of classical or quantum circuits into a single, uncloneable  quantum state. This indicates that, in spite of our results, quantum obfuscation may be significantly more powerful than its classical counterpart.
\end{abstract}

%\begin{keywords}
%Obfuscation, Encryption, Quantum \end{keywords}
%\newpage
%\tableofcontents


%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}\label{sec:intro}
%%%%%%%%%%%%%%%%%%%%%%

Arguably, the most powerful theoretical cryptographic primitive is \emph{obfuscation}: the ability to \emph{encrypt functionality}. Obfuscation implies (with some caveats) the ability to perform almost any cryptographic task imaginable, including public-key and fully-homomorphic encryption. Unlike in the case of data encryption, our theoretical understanding of obfuscation is still fairly limited. In the standard formulation, an obfuscator is an efficient algorithm which reads programs as input, and produces programs as output, and satisfies three properties: 
\begin{enumerate}\label{def:obf-informal}
\item \emph{functional equivalence:} the input/output functionality of the input program does not change;
\item \emph{polynomial slowdown:} if the input program is efficient, then the output program is efficient;
\item \emph{obfuscation:} the code of the output program is ``hard to understand.''\label{informal-obfuscation-condition}
\end{enumerate}
The last condition can be formulated rigorously in a number of ways. One possibility is the so-called ``virtual black-box'' condition, which says that the obfuscated program is no more useful than a black box which simply accepts inputs and produces outputs. This is impossible to achieve in the classical world~\cite{BGIRSVY12}. Another formulation of (3.) is computational-indistinguishability obfuscation; promising candidates and numerous applications have been proposed for this case~(see, e.g.,~\cite{GGHRSW13, BGKPS14, BCCGKPR14, BZ14, BR14, GGHW14, HSW14}.)

Theoretical cryptography is significantly complicated by the advent of \emph{quantum computation.} Quantum computation poses a threat to some encryption schemes (e.g., RSA), and may also pose a threat to classical obfuscation schemes (see, e.g.,~\cite{BS16}). On the other hand, quantum mechanics also appears to enable certain cryptographic tasks (such as information-theoretically secure key exchange) that are impossible classically. It is thus natural to ask what quantum computation means for obfuscation of programs. In particular, we would like to answer the following questions:

\begin{itemize}
\item what are the ``right'' formulations of quantum-mechanical program obfuscation?
\item is it possible to quantumly obfuscate classical and/or quantum programs?
\item which of the classical results about obfuscation carry over to the quantum setting?
\item how do the applications of quantum obfuscation differ from the classical case?
\end{itemize}

Before continuing, we draw attention to the distinction between obfuscating \emph{programs} (e.g., Turing Machines) and obfuscating \emph{circuits}. While these two forms of obfuscation are closely related, there are some important technical differences. In this work, as in most theoretical works on obfuscation, we will focus on obfuscation of circuits. We view the circuit model as more convenient; it is also more standard in quantum computation.

\subsection{Related work}
%%%%%%%%%%%%%%%%%%%%%%

In 2001, Barak et al. proved that classical virtual black-box obfuscation (VBB) is impossible~\cite{BGIRSVY01, BGIRSVY12}: there exist function families which are unobfuscatable (even inefficiently). They also showed the most sought-after applications of VBB are impossible to achieve generically. VBB was later proven possible for some limited forms of functionality~\cite{CD08, Wee05}; further limits were placed on VBB with auxiliary input~\cite{GK05}. Goldwasser and Rothblum defined \emph{indistinguishability obfuscation} and \emph{best-possible obfuscation}~\cite{GR07}, altering the obfuscation condition \eqref{informal-obfuscation-condition}. Under indistinguishability, it is required that the obfuscator maps functionally-equivalent circuits to indistinguishable distributions. Under best-possible, the obfuscator maps any circuit to a circuit from which the end user can ``learn the least.'' Both definitions have perfect, statistical, and computational variants. Goldwasser and Rothblum proved that the indistinguishability and best-possible are equivalent, and that the perfect and statistical versions are impossible (unless the PH collapses)~\cite{GR07}. In 2013, in a breakthrough result, Garg et al. proposed a convincing candidate for computational indistinguishability obfuscation~\cite{GGHRSW13}. Around the same time, another breakthrough by Sahai and Waters showed how to use a computational indistinguishability obfuscator to achieve a wide-range of applications, via a new ``punctured programs'' technique~\cite{SW14}. These applications include chosen-ciphertext-secure public-key encryption, injective trapdoor functions, and oblivious transfer. Sahai and Waters suggested that the applications were so wide-ranging that indistinguishability obfuscation might become a ``'central hub' for cryptography''~\cite{SW14}. These two breakthroughs were followed by a flurry of new activity in the area (see, e.g.,~\cite{BGKPS14, BCCGKPR14, BZ14, BR14, GGHW14, HSW14}).

Unlike classical obfuscation, quantum obfuscation is essentially an unexplored topic, and the present work appears to be the first rigorous treatment of the foundational questions. The question of whether quantum obfuscation is possible was posed as one of Scott Aaronson's ``semi-grand challenges'' for quantum computation~\cite{Aar05}. Since so little work on quantum obfuscation has appeared, we briefly mention some results that we believe are related. In~\cite{Aar09}, Aaronson proposed two relevant results. The first was a \emph{complexity-theoretic no-cloning theorem}~\cite{Aar09, AC12}, stating that cloning an unknown, random state by means of a black-box ``reflection oracle'' requires exponentially many queries. The second theorem stated that an oracle exists relative to which ``software copy-protection'' is possible. Mosca and Stebila proposed a black-box quantum money scheme, and suggested the possibility of using a quantum circuit obfuscator in place of the black box~\cite{MS10}. More recently, Alagic, Jeffery and Jordan proposed obfuscators for both classical (reversible) circuits and quantum circuits, based on ideas from topological quantum computation~\cite{AJJ14}. The proposed obfuscator compiles circuits into braids using certain high-dimensional representations of the braid group, and then applies an algorithm for putting braids into normal form. This obfuscator satisfies perfect indistinguishability for a restricted set of circuit equivalences. The cryptographic usefulness of such an obfuscator is unclear at this time.

\subsection{Summary of results}
%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Quantum black-box obfuscation}
%%%%

\paragraph{Definitions.} We define the following new notions.

\begin{enumerate}
\item \textbf{Quantum black-box obfuscator.} This is a polynomial-time quantum algorithm (QPT) $\algo O$ which accepts quantum circuits $C$ as input, and produces quantum states $\algo O(C)$ as output. It preserves functionality: there is a public algorithm for using $\algo O(C)$ and any input state $\ket{\psi}$ to produce the state $C \ket{\psi}$\,. It satisfies a black-box condition: for polynomial-time quantum algorithms, possession of $\algo O(C)$ can be simulated by black-box access to $C$. This definition is a natural analogue of the classical black-box definition given in~\cite{BGIRSVY12}.
\item \textbf{Quantum ``two-circuit'' black-box obfuscator.} This obfuscator is precisely as above, except the obfuscation condition is strengthened to hold over arbitrary \emph{pairs of circuits} $(C_1, C_2)$. For us, this definition will be primarily useful because of its role in establishing certain impossibility results.
\item \textbf{Information-theoretic quantum black-box obfuscator.} This is a modification of the above definition, in which we posit that \emph{any} adversary with access to $\algo O(C)$ can be simulated by a \emph{polynomial-time} quantum simulator with black-box access to $C$. This definition is impossible classically for obvious reasons. It is not a priori clear if the quantum case is impossible: if $\algo O(C)$ is a single copy of a quantum state, even unbounded adversaries are restricted by no-cloning and the (in general irreversible) properties of measurement.
\end{enumerate}

\paragraph{Impossibility.} We place several important restrictions on quantum obfuscation. Our ideas are based on~\cite{BGIRSVY12}, with several important quantum adaptations, including a new application of IND-CCA1 quantum encryption~\cite{ABFGSS16}.
\begin{enumerate}
\item \textbf{Two-state black-box obfuscation is impossible.} We prove that there exist families of circuit pairs which can reveal a secret if one is in possession of a circuit description for both of them, but not if one only has black-box access. This impossibility persists even if the obfuscation output is a quantum state, as opposed to a circuit description. Unlike the other results, it is also true even if the obfuscated states are \emph{not reusable.}
\item \textbf{If qOWFs exist, then obfuscation with more than one output is impossible.} For this proof, we combine the pairs from the circuit families in the two-circuit impossibility proof in order to build a single unobfuscatable family. The ability to execute obfuscated states from this family \emph{on themselves} is crucial here, and has two requirements: (i.) access to more than one obfuscation, even if the obfuscations are quantum states, and (ii.) secure encryption, which in turn requires the existence of qOWFs. 
\item \textbf{Classical algorithms for quantum obfuscation are impossible, unconditionally.} This result follows directly from the previous result and Application 1 below. It can be viewed as an extension of the original Barak et al. impossibility result to the case of quantum functionality and quantum adversaries.
\end{enumerate}
We emphasize that, while our techniques are very similar to Barak et al., our results are not a simple consequence of the fact that classical functions (and in particular, the Barak et al. unobfuscatable functions) are special cases of quantum functions. This ``special case'' argument fails for obvious reasons when the output of the obfuscator can be a quantum state. It also fails when the output is a circuit: (i.) one can now specify (approximate) quantum circuits for classical functions, (ii.) the black-box simulator now has quantum access, which is significantly more powerful than classical (see, e.g., ~\cite{HR14}) and (iii.) the Barak et al. adversary is insufficient since it can only perform classical gates homomorphically. 

\paragraph{Applications.} We then move on to discuss potential applications of quantum black-box obfuscators. Some of these applications may still be possible, in some form, in spite of our impossibility results. Some are analogues of known classical applications, while the last is special to the quantum setting. We remark that, since black-box obfuscation implies computationally best-possible obfuscation (which, in turn, implies computational indistinguishability obfuscation (iO)~\cite{GR07}) the numerous applications of iO may also be available quantumly.

\begin{enumerate}
\item \textbf{Quantum-secure one-way functions.} We show that, if there exists a classical probabilistic algorithm for quantum obfuscation, then quantum-secure one-way functions exist. 
\item \textbf{Private-key quantum encryption for long messages.} This application uses only the obfuscator, and no other assumptions. Such schemes normally require the qOWF assumption.
\item \textbf{Public-key quantum encryption from IND-CPA private-key quantum encryption.} In this case, we show (via quantum semantic security~\cite{ABFGSS16}) that providing the obfuscated encryption circuit as the public key transforms private-key encryption into public-key encryption. In this case, we require a stronger notion of obfuscation, which is guaranteed \emph{in the presence of auxiliary information.}
\item \textbf{Public-key quantum money}. Using circuit obfuscation to produce public-key quantum money was first proposed by Mosca and Stebila~\cite{MS10}, using a theorem of Aaronson and Christiano~\cite{Aar09, AC12}. We outline the idea, and adapt it based on the new limitations placed by our results.
\end{enumerate}

We emphasize that all the above applications except quantum money also work for achieving \emph{classical functionality} from a quantum obfuscator; however, depending on the details of the obfuscator and the application, this may require quantum algorithms for encryption and decryption, or even quantum ciphertexts.


\subsubsection{Quantum indistinguishability obfuscation}
%%%%

We also consider quantum versions of indistinguishability and best-possible obfuscation~\cite{BGIRSVY12, GR07}, and prove analogues of the central results of those papers. 

\begin{enumerate}
\item \textbf{Quantum indistinguishability obfuscator.} Just as in the black-box definition, this is a QPT $\algo O$ which accepts quantum circuits $C$ as input, and produces ``functionally-equivalent'' quantum states $\algo O(C)$ as output. The obfuscation condition now states that functionally equivalent circuits are mapped to \emph{indistinguishable states}. Based on the type of this indistinguishability, there are three variants: perfect, statistical, and computational.
\item \textbf{Quantum best-possible obfuscator.} In this case, the obfuscation condition demands that $\algo O(C)$ is the state that ``leaks least,'' among all states which are ``functionally-equivalent'' to $C$. There are again three variants: perfect, statistical, and computational.
\item \textbf{Equivalence of definitions.} We prove that each of the three variants of quantum indistinguishability obfuscation is equivalent to the analogous variant of quantum best-possible obfuscation, so long as the obfuscator is efficient.
\item \textbf{Impossibility of perfect and statistical indistinguishability obfuscation.} We give a quantum version of the main result of~\cite{GR07}: perfect and statistical quantum indistinguishability obfuscation is impossible, unless coQMA is contained in QSZK. An analogous containment in the classical setting (i.e., coMA $\subseteq$ SZK) would imply a collapse of the PH to the second level. For the case of obfuscating arbitrary quantum computations (i.e., CPTP maps), we obtain that statistical quantum iO would imply PSPACE $\subseteq$ QSZK. %One consequence of these results is that extending the obfuscator proposed in~\cite{AJJ14} to full indistinguishability is impossible, barring highly unlikely collapses of complexity classes.
\item \textbf{Application: witness encryption for QMA.} We show that a quantum indistinguishability obfuscator enables witness encryption for QMA. A witness encryption scheme for a language $L$ in QMA encrypts plaintexts $x$ using a particular instance $l$. The security condition states that, if $l \in L$, then a valid witness $w$ for $l \in L$ allows decryption; on the other hand, if $l \notin L$, then ciphertexts are indistinguishable. While witness encryption has several applications classically~\cite{GGSW13}, the quantum analogue has not been considered previously.
\end{enumerate}

We remark that, in the classical setting, indistinguishability obfuscation also implies functional encryption~\cite{GGHRSW13} and many more applications through the ``punctured programs'' technique developed by Sahai and Waters~\cite{SW14}. We suspect that these results can also be adapted to the quantum setting, but leave them open for now.

\subsection{Notation and terminology}\label{sec:notation}
%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Classical.}

We will assume that the state space of a classical device can be identified with sets of bitstrings, i.e., $\{0, 1\}^n$ for some positive integer $n$. The notation $x \inrand \{0, 1\}$ will mean that $x$ is an $n$-bit string selected uniformly at random. The set of all bitstrings (of arbitrary length) will be denoted by $\{0, 1\}^*$. Classical functions will then be maps $f : \{0, 1\}^n \rightarrow \{0, 1\}^m$ from one set of bitstrings to another. We will also sometimes consider function families, written $f : \{0, 1\}^* \rightarrow \{0, 1\}^*$; these can be thought of as a function family $\{f_n\}_{n>0}$ indexed by the input size $n$. 

A classical circuit $C$ is a sequence of local boolean gates which, when composed together, implement some (in general irreversible) function $f_C: \{0, 1\}^n \rightarrow \{0, 1\}^m$. The input size of $C$ is $n$, the output size is $m$, and the number of gates is denoted by $|C|$. A probabilistic circuit is also a circuit, but with the input bits divided into two registers: the input register, and the ``coin'' register. A normal execution of a probabilistic circuit involves initializing the coin register with completely random bits, and inserting the input into the input register. We will frequently discuss \textbf{circuit ensembles}; these are infinite families $\{C_n\}_{n > 0}$ of circuits, one for each possible input size, so that the size of circuit $C_n$ is bounded by some fixed polynomial function of $n$.  We say that a circuit ensemble is \textbf{uniform} if there is a deterministic polynomial-time Turing Machine which, on input $1^n$, outputs a classical description of $C_n$.  We will also sometimes make use of \textbf{distributions of circuit ensembles}; these are infinite families $\mathcal C = \{\mathcal C_n\}_{n > 0}$ where each $\mathcal C_n$ is a finite family of circuits of input size $n$, along with a probability distribution $P_{\mathcal C, n}$. For a bitstring $x$, the notation $\mathcal C(x)$ will then denote the probability distribution (on bitstrings) resulting from running a random circuit from the family $\mathcal C_{|x|}$, selected according the distribution $P_{\mathcal C, |x|}$.

A \textbf{deterministic classical algorithm} $\algo A$ is simply a circuit ensemble. Running $\algo A$ on an input bitstring $x$ involves selecting the circuit with the appropriate input size, and executing it with input $x$. If the circuit ensemble is uniform, we will say that $\algo A$ is efficient; more precisely, it is then a classical deterministic polynomial-time algorithm (\textbf{PT} for short.) A \textbf{probabilistic algorithm} $\algo A'$ is an algorithm whose circuits are probabilistic. Running $\algo A'$ on an input bitstring $x$ involves selecting the circuit with the appropriate input size, initializing its coin register with uniformly random bits, and then executing it with input $x$. If the circuits of $\algo A'$ are polynomial-time uniform, we say that $\algo A'$ is an efficient, or classical probabilistic polynomial-time algorithm (\textbf{PPT} for short.) We will frequently use PPTs to model the most general efficient classical algorithms.

\paragraph{Quantum.}

For our purposes, the space of pure states of a quantum device will be identified with a Hilbert space $\mathcal H_n \cong (\C_2)^{\otimes n}$ of a finite number $n$ of qubits. We will identify some fixed orthonormal basis (called the \emph{computational basis}) of $\mathcal H_n$ with the corresponding space $\{0, 1\}^n$ of classical states, so that, e.g, $\ket{x}$ for $x \in \{0, 1\}^n$ denotes a basis element of $\mathcal H_n$. The space of density operators (i.e., general quantum states) of $n$ qubits will be denoted $\states (\mathcal H_n)$; this is the set of positive semidefinite, Hermitian trace-one operators in $\End(\mathcal H_n)$. A state in $\states (\mathcal H_n)$ can be interpreted as a probabilistic mixture $\sum_j p_j \ket{\varphi_j}\bra{\varphi_j}$ of pure states, albeit not in a unique way. We will discuss valid quantum transformations of three types. The first are measurements, which act on a state $\ket{\psi} \in \mathcal H_n$ by projecting some or all of the qubits into the computational basis states $\{\ket{0}, \ket{1}\}$. The second are unitary maps, i.e., linear operators $U: \mathcal H_n \rightarrow \mathcal H_n$ satisfying $U^\dagger U = \one_n$, where $\one_n$ denotes the $n$-qubit identity operator. The third are CPTP maps, i.e., completely positive trace-preserving maps $\Phi : \states (\mathcal H_n) \rightarrow \states (\mathcal H_m)$. CPTP maps are the most general type of evolution, encompassing unitary maps, measurement, and adding or discarding (or tracing out) qubits. For example, a unitary operator $U \in U(\mathcal H_n)$ can be expressed as a CPTP map by writing $\rho \mapsto U\rho U^\dagger$, where $\rho \in \states (\mathcal H_n)$.

A \textbf{quantum circuit} $C$ is a sequence of local unitary gates on a fixed number (say $n$) of qubits; these gates, when composed together, implement some unitary operator $U_C \in U(2^n)$. Definitions of circuit ensembles and distributions over circuit ensembles are defined precisely as in the classical case. A \textbf{quantum polynomial time algorithm} (or \textbf{QPT} for short) $\mathcal A$ is a uniform ensemble of quantum circuits; algorithms can also include measurements and discarding (or tracing-out) of subsystems, so long as these also admit efficient classical descriptions. The input and output size of a quantum algorithm can vary, and will have to be deduced from context. For example, given a QPT $\mathcal A$, the expression $\Pr[\mathcal A(\ket{0^n}) = 1]$ will take the value zero unless $\mathcal A$ has a specific, labeled output qubit which is measured at the end of the computation.

%%%%%%%%%%%%%%%%%%%%%%
\subsection{Quantum encryption}\label{sec:encryption}
%%%%%%%%%%%%%%%%%%%%%%

In this section, we recall an encryption scheme for quantum states, with computational assumptions~\cite{ABFGSS16}. The scheme satisfies a notion of non-adaptive chosen-ciphertext security, under the assumption that quantum-secure one-way functions exist. We will need quantum-secure one-way functions (qOWF) and pseudorandom functions (qPRFs), and quantum encryption schemes, all defined in \expref{Appendix}{app:primitives}. We will also need the following result.

\begin{theorem}\cite{HILL99, Zhandry2012}
\label{thm:qOWF-implies-qPRF}If qOWFs exist, then so do qPRFs.
\end{theorem}

Next, recall the quantum one-time pad (QOTP). To encrypt a single-qubit state $\rho$, we use two classical random bits to select a Pauli matrix $P \in \{\one, X, Y, Z\}$, and apply $\rho \mapsto P \rho P^\dagger$. To encrypt an $n$-qubit quantum state $\rho$, we select $r \inrand \{0,1\}^{2n}$ and apply $\rho \longmapsto P_r \rho P_r^\dagger$,
where $P_r$ denotes the element of the $n$-qubit Pauli group indexed by $r$. The QOTP only provides information-theoretic one-time secrecy. We will need stronger security, as follows.

\begin{definition}\label{def:IND}
A symmetric-key quantum encryption scheme is IND-secure if for all QPTs $\algo A, \algo A'$,
$$
\left|\prob[ (\algo A' \circ \Enc_k \otimes \one_s \circ \algo A) \cdot 1^n = 1] -
\prob[ (\algo A' \circ \Xi_{\Enc_k \ket{0^m}\bra{0^m}} \otimes \one_s \circ \algo A) \cdot 1^n = 1] \right|
\leq \negl(n)\,,
$$ 
where $\Xi_\sigma: \rho \mapsto \sigma$ is the ``forgetful'' map, and $s$ is a polynomial function of $n$. If $\algo A$ and $\algo A'$ have oracle access to $\Enc_k$, then we say that the scheme is IND-CPA secure. If in addition $\algo A'$ has oracle access to $\Dec_k$, then we say that the scheme is IND-CCA1 secure.
\end{definition}

It turns out that qPRFs can be used to construct simple symmetric-key quantum encryption schemes that satisfy all of the above security conditions. Let $f$ be a length-doubling qPRF, and consider the scheme which encrypts $\rho$ by choosing $r \inrand \{0, 1\}^n$ and outputting $\ket{r}\bra{r} \otimes P_{f_k(r)} \rho P_{f_k(r)}^{\dagger}$ (and decrypts in the obvious way). This scheme satisfies IND-CCA1~\cite{ABFGSS16}. Combining this with \expref{Theorem}{thm:qOWF-implies-qPRF}, we have 
\begin{theorem}\label{thm:qOWF-implies-qSKE}
If qOWFs exist, then so do IND-CCA1-secure symmetric-key quantum encryption schemes.
\end{theorem}

%%%%%%%%%%%%%%%%%%%%%%
\section{Quantum black-box obfuscation}\label{sec:black-box}
%%%%%%%%%%%%%%%%%%%%%%

%In this section, we discuss the virtual black-box framework for quantum obfuscation. We begin with definitions (\expref{Section}{sec:vbb-definitions}) and applications (\expref{Section}{sec:vbb-applications}), and finish with new impossibility results (\expref{Section}{vbb:impossibility}). 

\subsection{Definitions}\label{sec:vbb-definitions}
%%%%%%%%%%%%%%%%%%%%%%

Obfuscation involves giving an untrusted party an object $\algo O(C)$ for implementing some chosen functionality $f_C$. In the black-box formulation of obfuscation, we demand that this is effectively all that the untrusted party will ever be able to do. The rigorous formulation uses the simulation paradigm: anything that is efficiently learnable from the obfuscated circuit, is also efficiently learnable by evaluating $f_C$ some polynomial number of times~\cite{BGIRSVY12}.

\begin{definition}\label{def:vbb-obfuscator}
A \textbf{black-box quantum obfuscator} is a quantum algorithm $\algo O$ and a QPT $\algo J$ such that whenever $C$ is an $n$-qubit quantum circuit, the output of $\algo O$ is an $m$-qubit state $\algo O(C)$ satisfying
\begin{enumerate}
\item (polynomial expansion) $m = \text{poly}(n)$;
\item (functional equivalence) $\bigl\| \algo J ( \algo O(C) \otimes \rho ) - U_C \rho U_C^\dagger \bigr\|_\emph{tr} \leq \negl(n)$ for all $\rho \in \states(\mathcal H_n);$
\item (virtual black-box) for every QPT $\mathcal A$ there exists a QPT $\mathcal S^{U_C}$ such that
$$
\Bigl| \emph{Pr}\bigl[\mathcal A(\mathcal O(C)) = 1\bigr] - \emph{Pr}\bigl[\mathcal S^{U_C}\bigl(\ket{0^n}\bigr) = 1\bigr] \Bigr| \leq \negl(n)\,.
$$
\end{enumerate}
\end{definition}
We emphasize that while the ``interpreter'' algorithm $\algo J$ must be polynomial-time, the obfuscator itself need not be. One could consider variants of \expref{Definition}{def:vbb-obfuscator} where the interpreter algorithm is fixed once and for all, or where $\algo O(C)$ itself consists of both a quantum ``advice state'' and a circuit which the end user should execute on the advice state and the desired input. It is straightforward to show that all of these variants are equivalent, in the sense that a black-box quantum obfuscator of each variant exists if and only if the other variants exist. 

The no-cloning theorem opens up the possibility of \emph{computationally unbounded adversaries.} The appropriate definition is a modification of \expref{Definition}{def:vbb-obfuscator}, where we replace the third condition with the following:

\begin{enumerate}
\setcounter{enumi}{2}
\item \emph{(information-theoretic virtual black-box) for every quantum adversary $\mathcal A$ there exists a QPT $\mathcal S^{U_C}$ such that}
$$
\Bigl| \prob \bigl[\mathcal A(\mathcal O(C)) = 1\bigr] - \prob \bigl[\mathcal S^{U_C}\bigl(\ket{0^n}\bigr) = 1\bigr] \Bigr| \leq \negl(n)\,.
$$
\end{enumerate}

\subsection{Applications of efficient black-box obfuscators}\label{sec:vbb-applications}
%%%%%%%%%%%%%%%%%%%%%%

In this section, we give a few example applications of quantum black-box obfuscation. The proofs are fairly simple and are given in \expref{Appendix}{app:proofs}. Our impossibility results will put some restrictions on these applications; some of the applications will be used in the impossibility proofs themselves. While most of the applications are written in terms of quantum functionality (e.g., encryption of quantum states), one can just as well consider the weaker case of classical functionality, achieved via quantum means (e.g., via a quantum algorithm for obfuscation.)

\paragraph{Quantum-secure one-way functions.}
%%%

The first application yields qOWFs exist, and thus also quantum encryption (\expref{Theorem}{thm:qOWF-implies-qSKE}). An obfuscator is \emph{perfect} if the functional equivalence condition is exact (that is, trace distance $0$).  

\begin{prop}
If there exists a classical probabilistic algorithm which is a (perfect) quantum black-box obfuscator, then quantum-secure one-way functions exist.
\end{prop}
The proof is very similart o Lemma 3.8 in \cite{BGIRSVY12}, but fails if the obfuscator is a quantum algorithm---even if its output is itself classical. One-way functions must be deterministic; while one can turn a classical probabilistic algorithm into a deterministic one by making the coins part of the input, this is not possible quantumly. 

\paragraph{Private-key encryption for long messages.}
%%%

Let $(\algo O, \algo J)$ be a quantum black-box obfuscator. We consider an adaptation of the unitary operator $U_{a, b}$ defined above, but now with Pauli group action instead of XOR and two registers:
$$
V_{r, k} : \ket{x,\, y} \longmapsto
\begin{cases}
\ket{x,\, P_r^\dagger y} &\text{ if } x = k;\\
\ket{x,\, y} &\text{ otherwise},
\end{cases}
$$
Now consider the following scheme for encrypting $l(n)$-qubit quantum states.
\begin{itemize}
\item $\KeyGen(1^n)$: output $k \inrand \{0, 1\}^n$;
\item $\Enc_{k}(\rho)$: choose $r \inrand \{0, 1\}^{2\,l(n)}$; output $P_r \rho P_r^\dagger \otimes \algo O(V_{r, k})$;
\item $\Dec_{k}(\sigma \otimes \tau)$: output  the second register of $\algo J(\tau \otimes \ket{k}\bra{k} \otimes \sigma)$.
\end{itemize}
Correctness is a consequence of the functionality-preserving property. For a security argument, see \expref{Appendix}{app:proofs}.

\paragraph{Public-key encryption from private-key encryption.}
%%%
For this application, we will need a stronger form of black-box obfuscation. Namely, the obfuscator should be secure in the presence of auxiliary information (see, e.g., Definition 3 in \cite{GK05}). This amounts to requiring that the black-box condition now states
$$
|\Pr[\algo A( \algo O(C) \otimes \rho) = \pi(C, \rho)] - \Pr[\algo S^{U_C}(\ket{0^n} \otimes \rho) = \pi(C, \rho)]| \leq \negl(n)\,,
$$
where $\pi$ is any predicate, and the auxiliary information $\rho$ is allowed to depend on $C$. It's conceivable that the construction is possible even without auxiliary information; we leave this as an open problem.

Let $\Pi = (\KeyGen, \Enc, \Dec)$ be a symmetric-key quantum encryption scheme, with classical keys. We define a public-key quantum encryption scheme $\Pi' = (\KeyGen', \Enc', \Dec')$ so that key generation outputs the key of $\Pi_S$ as the private key, and $\algo O(\Enc_k)$ as the public key. We will assume that the obfuscator outputs circuits, so that the public key is classical. One could also consider the case where public keys are quantum; more care is then required in setting down the definition of public-key schemes. A security proof sketch for $\Pi'$ is given in \expref{Appendix}{app:proofs}.

\paragraph{Public-key quantum money.}
%%%

The idea of ``quantum money'' first arose in work by Wiesner~\cite{Wie1983}, and was developed further in several works (see, e.g.,~\cite{Aar09, AC12, BBBW83, FGHLS12, MS10}). The core idea is simple: use a quantum state for representing currency in such a way that the no-cloning theorem of quantum mechanics prevents counterfeiting. A \emph{quantum money scheme} consists of two algorithms: \Mint, which produces quantum states, and \Verify, which accepts an input state and then either accepts or rejects. We imagine an authority (the bank) which runs \Mint repeatedly to produce money; \Verify should only accept states produced by the bank. Depending on the scheme, \Verify is executed by the bank (private-key money), or by any party (public-key money.)

%In this language, Wiesner's original idea~\cite{Wie1983} was for a private-key scheme for bills, which is as follows. Each execution of \Mint produces two random classical bitstrings $r, s \in \{0, 1\}^{2n}$ as well as an $n$-qubit quantum state $\ket{\psi_r}$, with each qubit initialized in one of the states $\ket{0}, \ket{1}, \ket{+}, \ket{-}$, as determined by the bits of $r$. The bank records the pair $(r, s)$ in a secret table, and publishes $(s, \ket{\psi_r})$. The bank verifies by using $s$ to look up the correct $r$ in the table, and then performing the measurements in the correct basis and checking the results against $r$. 

While private-key money schemes are relatively straightforward to construct, public-key proposals appear to be much more difficult. Here we discuss how to use an obfuscator to turn private-key money schemes to public-key ones. The use of an obfuscator to create a particular quantum money scheme was considered by Mosca and Stebila~\cite{MS10}. Their scheme (in our language) is as follows. Each execution of \Mint produces a random (e.g., approximate $t$-design) $n$-qubit quantum state $\ket{\psi}$, together with the obfuscation $\mathcal O(U_\psi)$ of a circuit for $U_\psi = \one - 2\ket{\psi}\bra{\psi}$. The bill consists of the pair $(\mathcal O(U_\psi), \ket{\psi})$. $\Verify(\ket{\varphi})$ consists of executing the following:
$$
\Qcircuit @C=1em @R=1.0em {
\lstick{\ket{0}} &\gate{H} 	&\ctrl{1}				&\gate{H} 	&\qw &\meter\\
\lstick{\ket{\varphi}} &\qw 	&\gate{\algo O(U_\psi)}	&\qw 	&\qw &\qw\\ \\
}
$$
and accepting iff the measurement returns $1$. It's easy to check that the above succeeds only on valid states; moreover, in that case, the state $\ket{\psi}$ is output in the second register, so that verification can be repeated. One can show resistance of the above scheme to counterfeiting via a Complexity-Theoretic No-Cloning Theorem~\cite{Aar09, AC12}. 

Unfortunately, we will show that obfuscation of circuits into circuits is impossible. What remains possible is a setting in which both $\ket{\psi}$ and $\mathcal O(U_\psi)$ are quantum states, and another circuit (which is publicly known and independent of $\ket{\psi}$) is used for verification. Moreover, as we will also show, any black-box obfuscation scheme which outputs states that can be efficiently cloned is also impossible. We thus conjecture the following.
\begin{conjecture}
If quantum black-box obfuscators exist, then so does public-key quantum money.
\end{conjecture}

\subsection{Impossibility results}\label{vbb:impossibility}
%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Impossibility of two-circuit obfuscation}\label{sec-twocircuit}
%%%
We begin by showing that quantum black-box obfuscation is impossible in any setting where the adversary can gain access to two outputs of the obfuscator on \emph{different} inputs. We define such a ``black-box two-circuit obfuscator''  by following Definition \ref{def:vbb-obfuscator} but with the following strengthening of the virtual black-box condition:
\begin{enumerate}
\setcounter{enumi}{2}
\item \emph{(two-circuit virtual black-box) for every pair of quantum circuits $C_1$ and $C_2$ and every quantum adversary $\mathcal A$ there exists a quantum simulator $\mathcal S^{U_{C_1}, U_{C_2}}$ and a negligible $\epsilon_2$ such that}
$$
\Bigl| \text{Pr}[\mathcal A(\mathcal O(C_1) \otimes \mathcal O(C_2)) = 1] - \text{Pr}\bigl[\mathcal S^{U_{C_1}, U_{C_2}}\bigl(\ket{0}^{\otimes |C_1| + |C_2|}\bigr) = 1\bigr] \Bigr| \leq \epsilon_2(n, \min\{|C_1|,|C_2|\})\,.
$$
\end{enumerate}

We now show that there exists a family of circuits which is unobfuscatable under the above definition. We emphasize that our result holds even when the outputs of the obfuscator are quantum states, and even if these states are \emph{single-use only}, i.e., if the interpreter $\mathcal J$ irrevocably destroys the obfuscated state during use. 

We first define a \emph{circuit-pair family} to be an ensemble of distributions over pairs of circuits. More precisely, if $\mathcal C$ is a circuit-pair family, then there exists a Turing machine M which, on input a positive integer parameter $n$ (in unary), outputs a classical description of a pair of circuits $(C_n, D_n)$ drawn at random from some distribution $\mathcal C_n$ on pairs of poly$(n)$-size circuits. If $M$ is polynomial-time, then we say that $\mathcal C$ is a \emph{poly-time circuit-pair family.}

We also define a \emph{state-pair family} analogously. If $\mathcal C'$ is a state-pair family, then there exists a (not necessarily polynomial-time) quantum algorithm which, on input $n$ in unary, outputs a pair of density operators $(\rho_n, \sigma_n)$ drawn at random from some distribution $\mathcal C_n'$ on quantum states on poly$(n)$-many qubits. Given a circuit-pair family $\mathcal C$ and a state-pair family $\mathcal C'$, we say that $\mathcal C'$ is an obfuscation of $\mathcal C$ if there exists a computable map $\mathcal C \rightarrow \mathcal C'$ assigning to each circuit a corresponding state, in a manner that satisfies the two-circuit obfuscation definition above.

%With these definitions, we can now state our first impossibility result.

\begin{theorem}\label{thm:pair-impossibility}
There exists a poly-time circuit-pair family $\mathcal C$ such that no state-pair family is an obfuscation of $\mathcal C$.
\end{theorem}
\begin{proof}
Let $(\mathcal O, \mathcal J)$ be a black-box quantum two-circuit obfuscator. 
The poly-time quantum circuit-pair family $\mathcal C$ consists of quantum circuits for implementing the following pairs of unitary operators. Each pair is parameterized by an input size $n$, as well as bitstrings $a, b$ chosen uniformly at random from $\{0, 1\}^n$.
\begin{align}\label{eq:pair-impossible}
U_{a, b} : \ket{x,\, y} \longmapsto
\begin{cases}
\ket{x,\, y \oplus b} &\text{ if } x = a;\\
\ket{x,\, y} &\text{ otherwise}.
\end{cases}
\qquad \qquad
V_{a, b} : \ket{C,\, z} \longmapsto
\begin{cases}
\ket{C,\, z \oplus 1} &\text{ if } C(a) = b;\\
\ket{C,\, z} &\text{ otherwise}.
\end{cases}
\end{align}
The registers indexed by $x$ and $y$ are of size $n$. The register indexed by $C$ accepts a circuit description (under some fixed encoding), and needs to be able to handle inputs of size $|\algo O(C_{a, b})|$ (i.e. of size equal to the number of qubits in the state $\algo O(C_{a, b})$). Here $C_{a, b}$ is a fixed, explicit poly$(n)$-size circuit for $U_{a, b}$. The second register of $V_{a, b}$ has size one. 

Both unitaries can be implemented by efficient quantum circuits. Choose some particular set of such circuits, and denote them by $C_{a,b}$ and $D_{a,b}$, respectively. The idea for the proof is as follows. Consider an adversary $\algo A$ which does not know $a$ and $b$, and consider two scenarios: in the first, $\algo A$ is given access to \emph{any} pair of \emph{circuits} that implement $U_{a, b}$ and $V_{a, b}$; in the second, $\algo A$ only has oracle access to $U_{a, b}$ and $V_{a, b}$. The point is that, in the first case, $\algo A$ can execute $V_{a, b}$ on a circuit for $U_{a, b}$; provided that the latter is not too long, $\algo A$ will achieve something that is impossible to do with only black-box access. Specifically, it is only in the first case that $\algo A$ will be able to tell if the first circuit/oracle implements $U_{a, b}$, or if it has surreptitiously been replaced by the identity operator!

Things are somewhat complicated by the fact that the obfuscator outputs states instead of circuits. We will need to enable $\algo A$ to execute these states on one another. It will thus be necessary to replace $D_{a, b}$ with a related circuit $D_{a, b}'$. Roughly speaking, this circuit will check if its input, when interpreted as a quantum advice state to the algorithm $\algo J$, maps the input $a$ to the output $b$. A precise description follows. First, $D_{a, b}'$ will have three registers: an input register of $m$ qubits, a work register of $2n$ qubits, and an output register of $1$ qubit initialized in the $|0\rangle$ state. When given as input a quantum state $\rho$ on $m$ qubits, it will initialize the first $n$ bits of the work register to $|a\rangle$, then execute the appropriate unitary circuit of $\algo J$ on $\rho \otimes \ket{a}$. Finally, if the output register of the latter computation contains $\ket{b}$, $D_{a, b}'$ will flip the contents of the output register. We remark that, by a simple counting argument over circuits, this occurs for only an exponentially small fraction of possible input states $\rho$.

Recall that the $2n$-qubit identity operator is denoted by $\one_{2n}$, and is implemented by the empty circuit $I_{2n}$. We observe that, for every QPT algorithm $\mathcal S$ there exists a polynomial $t$ and a negligible $\epsilon_1$ so that:

\begin{equation}\label{eqn11}
\Bigl| \text{Pr}\bigl[\mathcal S^{U_{a,b}, D_{a,b}'}\bigl(\ket{0}^{\otimes t(n)}\bigr) = 1\bigr]
- \text{Pr}\bigl[\mathcal S^{Id_{2n}, D_{a,b}'}\bigl(\ket{0}^{\otimes t(n)}\bigr) = 1\bigr] \Bigr| 
\leq \epsilon_1(n)\,.
\end{equation}
Here the probability is taken over uniformly random $a$ and $b$ and all of the measurement outcomes of $\algo S$. The above is an easy corollary of the tightness of the Grover bound for unstructured quantum search \cite{BBBV}. Indeed, given the definitions of $U_{a, b}$ and $D_{a, b}'$, it's clear that with only polynomial queries and no knowledge of $a$ or $b$, $\algo S$ is faced precisely with unstructured search for an exponentially small ``marked space.'' This marked space is only encountered if $\algo S$ correctly guesses $a$, or correctly guesses an obfuscation of a circuit that maps $a$ to $b$.
  
Now consider the QPT algorithm $\mathcal{A}$ that, given as input the states $\mathcal{O}(C)$ and $\mathcal{O}(D)$, executes the quantum algorithm $\mathcal{J}$ on their tensor product, accepting if and only if the outcome is $1$. This succeeds with constant probability $\alpha > 0$ if $C$ is functionally equivalent to $C_{a,b}$ and $D$ is functionally equivalent to $D_{a,b}'$. This same algorithm $\algo A$ accepts with negligible probability when $C$ is functionally equivalent to $I_{2n}$ (and $D$ is still functionally equivalent to $D_{a, b}'$); indeed, this only happens is if $a = b$. Thus there exists a negligible function $\epsilon_2$ so that:

\begin{equation}\label{eqn2}
\Bigl| \text{Pr}\bigl[\mathcal A(\mathcal{O}(D'_{a,b}),\mathcal{O}(I_{2n})) = 1\bigr]
- \text{Pr}\bigl[\mathcal A\bigl(\mathcal{O}(D'_{a,b})\otimes\mathcal{O}(C_{a,b})\bigr) = 1\bigr] \Bigr| 
\geq \alpha-\epsilon_2(n)\,.
\end{equation}

The circuit-pair family $\mathcal C$ is thus defined as follows. The distribution $\mathcal C_n$ is generated by choosing $a, b$ and $r$ uniformly at random; if $r = 0$, we output the circuit pair $(C_{a,b}, D'_{a,b})$, if $r = 1$ we output $(I_{2n}, D'_{a,b})$. For this distribution, equations \eqref{eqn11} and \eqref{eqn2} together show that no state-pair family is an obfuscation of $\mathcal C$.
\qed
\end{proof}

\subsubsection{Generalizing the impossibility result}
%%%

We now extend the two-circuit impossibility proof to the case of obfuscating a single circuit. We require an additional condition on the obfuscator: that each of its outputs is reusable a polynomial number of times. This condition is automatically satisfied by classical obfuscators (as well as quantum obfuscators with classical outputs), since their outputs can be perfectly copied.

\begin{definition}\label{def:vbb-reusable}
A \textbf{reusable-black-box quantum obfuscator} is a quantum algorithm $\algo O$ and a QPT $\algo J$ such that whenever $C$ is an $n$-qubit quantum circuit, $\mathcal{O}(C)$ is an $m$-qubit quantum state satisfying
\begin{enumerate}
\item (polynomial slowdown)  $m = \text{poly}(n, |C|)$;
\item (functional equivalence) $\bigl\| \algo J ( \mathcal O(C) \otimes \,\cdot\, ) - C \,\cdot\, C^\dagger \bigr\|_\diamond \leq \negl(n, |C|)$;
\item (reusability) after execution of $\algo J$, an output register contains a state which satisfies (2.);
\item (virtual black-box) for every QPT adversary $\mathcal A$ there exists a QPT simulator $\mathcal S^{U_C}$ such that:
$$
\Bigl| \emph{Pr}[\mathcal A(\rho_{(i)}) = 1] - \emph{Pr}\bigl[\mathcal S^{U_C}\bigl(\ket{0}^{\otimes |C|}\bigr) = 1\bigr] \Bigr| \leq \negl(n, |C|)\,.
$$
\end{enumerate}
\end{definition}

We are not concerned with how exactly $\algo J$ produces a copy of the reusable state (e.g., if the state is classical, then it's clear how to achieve this). We prove impossibility of the above definition in any setting where the adversary receives two copies of the obfuscator output, even on identical inputs. This is automatically satisfied if the obfuscator provides multiple copies in order to satisfy reusability, or if the state is (even approximately) cloneable. The key new obstacle is to prove impossibility even though the functionality for both copies is \emph{the same.}

To state the result, we define (in analogy to circuit-pair families and state-pair families) a \emph{circuit family} to be an ensemble of distributions over circuits, and a \emph{state family} to be an ensemble of distributions over states. A state family $\mathcal C'$ is said to be an obfuscation of a circuit family $\mathcal C$ if there exists a computable map $\mathcal C \rightarrow \mathcal C'$ assigning to each circuit a corresponding state, in a manner that satisfies \expref{Definition}{def:vbb-reusable}. We will prove the following.

\begin{theorem}\label{thm:single-impossibility}
If quantum-secure one-way functions exist, then there exists a quantum circuit family $\mathcal C$ such that no state family is a reusable-black-box quantum obfuscation of $\mathcal C$.
\end{theorem}

The full proof is somewhat involved, so we will first prove a simpler case: quantum circuits cannot be obfuscated into quantum circuits, under any of the definitions considered so far.  This corollary (stated below as \expref{Theorem}{thm:cor}) is arguably the most direct quantum generalization of the impossibility result of ~\cite{BGIRSVY01}. Once we have proved it, we will explain in \expref{Appendix}{app:proof-theorem-8} how the proof can be adapted to prove \expref{Theorem}{thm:single-impossibility}.

\begin{theorem}\label{thm:cor}
If quantum-secure one-way functions exist, then there exists a quantum circuit family $\mathcal C$ such that no quantum circuit family is a black-box obfuscation of $\mathcal C$.
\end{theorem}

\begin{proof}
Let $\mathcal O$ be a black-box quantum obfuscator satisfying \expref{Definition}{def:vbb-obfuscator}, such that its outputs are classical bitstrings. We may assume that these bitstrings are in fact quantum circuits under some particular encoding. To construct the unobfuscatable circuit family, we will need a notion of combining the functionality of two quantum circuits into one. 

\begin{definition} The {\bf combined quantum circuit} of a finite collection $\lbrace C_1,C_2,...,C_k \rbrace$ of $n$-qubit quantum circuits is the circuit that has two registers (a control register of $\log{k}$ qubits, and an input register of $n$ qubits) and, controlled on the value of the first register, applies the respective quantum circuit to the input register.   
\end{definition}

\noindent Notice that if each circuit $C_i$ in the collection is polynomial size, and $k$ is bounded by a polynomial in $n$, then the associated combined quantum circuit is also of polynomial size. We will denote the operation of combining circuits with $\#$. For example, the combined circuit of two circuits $C_1$ and $C_2$ is denoted $C_1 \# C_2$. 

Now recall the two circuits  $C_{a,b}$ and $D_{a,b}$ from Section \ref{sec-twocircuit}, as well as the circuit $I_{2n}$, which simply implements the identity operator on $2n$ qubits. Consider the combined quantum circuits $C_{a,b}\#D_{a,b}$ and $I_{2n}\#D_{a,b}$, sampled by selecting $a$ and $b$ uniformly at random from $\{0, 1\}^n$. We again choose $C = C_{a, b}$ or $C = I_{2n}$, each with probability $1/2$, and ask the adversary to determine which is the case. Using the same reasoning as in the proof of \expref{Theorem}{thm:pair-impossibility} from Section \ref{sec-twocircuit}, these combined quantum circuit distributions are indistinguishable from the perspective of any QPT simulator that is ignorant of $a$ and $b$, and is given only black-box access to $U_{C \# D_{a, b}}$.  On the other hand, unlike in the prior proof, it is not immediately apparent how to distinguish the two possibilities given a circuit description of $\algo{O}(C \#D_{a,b})$. Still, the idea is simple. Suppose we have two copies of the circuit. We can hard-wire the control register of one copy to implement $D_{a, b}$, and hard-wire the control register of the other copy to implement $C$. If we then run the first copy on the second, the result should be equivalent to implementing $D_{a, b}$ on input $C$, which will determine the nature of $C$ and conclude the proof just as in \expref{Theorem}{thm:pair-impossibility}.

Unfortunately, this idea does not work as stated, because the two circuit copies have the same size. Since they are functionally nontrivial, their input size is much smaller than their description, making it impossible to run one on the other. The core difficulty is that $D_{a,b}$ cannot be made large enough to universally execute circuits of size $|\algo O(C \# D_{a, b})| > p(|D_{a, b}|)$ where $p$ is the running time of $\algo O$. This issue arises in the classical proof as well, and is resolved as follows. First, note that we could have $D_{a, b}$ simply provide $a$ and $b$, thus offloading the gate-by-gate execution of $C$ to the algorithm $\algo A$ in the black-box definition. Unfortunately, this would also provide the simulator $\algo S$ with $a$ and $b$, enabling it to simulate $\algo A$. The resolution is to have $D_{a, b}$ provide \emph{encryptions of} $a$ and $b$, as well as a \emph{quantum fully-homomorphic encryption (QFHE) oracle} for homomorphically applying the gates of $C$. We emphasize that the functionality and security of the QFHE oracle crucially depends on the obfuscation property; in particular, an actual QFHE scheme is not required for the proof. Concretely, we prove the following Lemma, an analogue of Lemma 3.6 (including Claim 3.6.1) from~\cite{BGIRSVY12}.

\begin{lemma}\label{lemma-circuitdistribution}
If quantum-secure one-way functions exist, then for each $n \in \mathbb{N}$ and $a, b\in\{0,1\}^n$, there exists a distribution $\mathcal{D}_{a,b}$ over circuits such that:
\begin{enumerate}
\item There exists a PPT algorithm that, given $n\in\mathbb{N}$ and $a,b\in\{0,1\}^n$, samples from $\mathcal{D}_{a,b}$;
\item There is a QPT algorithm $\algo{A}$ so that $C \ket{a} \ket{0^n} = \ket{a}\ket{b}$ implies $\algo{A}^{U_D}(C, 1^n) = a$; this holds for all $n \in \mathbb{N}$, all $a,b\in\{0,1\}^n$, any $D\in \supp(\mathcal{D}_{a,b})$, and every $n$-qubit circuit $C$;
\item{For any QPT $S$, $\Pr[S^{U_D}(1^n)=a] \leq \negl(n)$, where the probability is over $a,b\in\{0,1\}^n$, $D\sim \mathcal{D}_{a,b}$, and the measurements of $S$.}	
\end{enumerate}
\end{lemma}

\begin{proof} The distribution $\mathcal D_{a, b}$ will be sampled by choosing $k, r \inrand \{0, 1\}^{2n}$. The bitstring $k$ is to serve as a private key for the IND-CCA1-secure symmetric-key quantum encryption scheme from \expref{Theorem}{thm:qOWF-implies-qSKE}. Each circuit $D\in \supp(\mathcal{D}_{a,b})$ will be a combination (again via \#) of the following three circuits. 
\begin{enumerate}
\item $E_{K,a}$; this outputs $\Enc_k(\ket{a})$, executed with randomness $r$. 
\item $\Homorcl_K(G,\rho)$; on input a gate description $G$ and a state $\rho$, it outputs $[\Enc_k \circ G \circ \Dec_k](\rho)$.
\item $B_{k,a,b}$; on input $\rho$, it outputs $\ket{a}$ if $\Dec_{k}(\rho)= \ket{b}$ and $\ket{0^n}$ otherwise.
\end{enumerate}
The $\Homorcl$ oracle requires randomness in order to re-encrypt the state. This is handled in the usual way, by expanding the input via a qPRF~\expref{Theorem}{thm:qOWF-implies-qPRF}. Clearly, given $a$ and $b$, $\mathcal{D}_{a,b}$ can be sampled efficiently by choosing $k$ uniformly at random and outputting the combined quantum circuit $D_{k, a, b} := E_{k,a}\#\Homorcl_{k}\#B_{k,a,b}$. This establishes Property 1 from the Lemma.  For Property 2, let $\algo{A}$ be the algorithm that, on input a quantum circuit $C$, (i.) uses the first two circuits comprising $D_{k,a,b}$ to homomorphically simulate $C$ gate-by-gate on $a$, and then (ii.) plugs the final state into $B_{K,a,b}$. 

To complete the proof of \expref{Lemma}{lemma-circuitdistribution}, we must verify Property 3, i.e., that no QPT simulator algorithm that has black-box access to  each of the three algorithms comprising $D_{K,a,b}$ can discover $a$ with non-negligible probability.  This amounts to showing that
\begin{equation}\label{eq:hom-gap}
\Bigl| \Pr[\mathcal S^{\Homorcl_k,\Enc_k}(\Enc_k(\ket{0})) = 1] 
- \Pr\bigl[\mathcal S^{\Homorcl_k,\Enc_k}(\Enc_k(\ket{a})) = 1 \Bigr| 
\leq \negl(n)\,,
\end{equation}
where the probabilities are over $k \inrand \{0,1\}^n$ and the measurement outcomes of $\algo{S}$. We proceed by contradiction, and assume that there's a QPT $\algo{S}$ that violates the claim. 

First, we replace the responses to all of $\algo{S}$'s queries to the $\Homorcl_k$ oracle with encryptions of $|0^n\rangle$, and use a hybrid argument to show that the success probability of $\algo S$ is unaffected. In the $i$-th hybrid, the first $i$ oracle queries of $\algo S$ are answered using $\Homorcl_k$, and the rest are answered with $\Enc_k(|0^n\rangle)$.  Any gap in distinguishing between the $i$ and $i+1$st hybrid must be due to the $i+1$st query $\algo S$ makes to $\Homorcl_k$. We use this to create a CCA1 adversary $\algo T$ as follows. The QPT $\algo T$ simulates $\algo S$ and replies to its first $i$ oracle queries by means of $\algo T$'s $\Enc_k$ and $\Dec_k$ oracles. Upon receiving the challenge ciphertext, $\algo T$ passes it to $\algo S$ as the response to its $i+1$st oracle query. Finally, $\algo T$ answers the remaining oracle queries of $\algo S$ with $\Enc_K(|0^n\rangle)$. If $\algo S$ violated \eqref{eq:hom-gap}, then $\algo T$ succeeds with non-negligible probability. We can thus replace the oracle queries of $\algo S$ with $\Enc_k(\ket 0)$; then $\algo S$ can distinguish encryptions of $|0^n\rangle$ from encryptions of $\ket{a}$ using only an encryption oracle, contradicting IND-CCA1 security. 
\qed 
\end{proof}

Now we are ready to describe the unobfuscatable family of quantum circuits and complete the proof of \expref{Theorem}{thm:cor}. First, for a fixed $a,b \in \{0, 1\}^n$ we let $\mathcal{D}_{a,b}$ be the distribution over circuits constructed in \expref{Lemma}{lemma-circuitdistribution}. Then consider the following two distributions over circuits: 
\begin{enumerate}
\item $\mathcal{F}_{n}$: Choose $a,b \inrand \{0,1\}^n$,  sample a circuit $D_{a, b}$ from $\mathcal{D}_{a,b}$ and output $C_{a,b}\# D_{a,b}$ 
\item $\mathcal{G}_{n}$: Choose $a,b \inrand \{0,1\}^n$,  sample a circuit $D_{a, b}$ from $\mathcal{D}_{a,b}$ and output $I_{2n}\# D_{a,b}$
\end{enumerate}
By Property 2 of \expref{Lemma}{lemma-circuitdistribution} there exists an algorithm $\algo{A}$ that, on input $\mathcal{O}(C_0)$, accepts if $C_0$ was sampled from $\algo{F}_n$ and rejects if $C$ was sampled from $\algo{G}_n$.  Thus there exists a constant $\alpha$ and a negligible function $\epsilon_1$ so that:
$$
\Bigl| \text{Pr}\bigl[\mathcal A(\mathcal{O}(\mathcal{F}_n)) = 1\bigr]
- \text{Pr}\bigl[\mathcal A\bigl(\mathcal{O}(\mathcal{G}_n)\bigr) = 1\bigr] \Bigr| 
\geq \alpha-\epsilon_1(n)\,.
$$
On the other hand, by Property 3 of \expref{Lemma}{lemma-circuitdistribution}, we know that for every QPT $S$ there exists some negligible function $\epsilon_2$ so that: 
$$
\Bigl| \text{Pr}\bigl[\mathcal S^{\mathcal{F}_n}\bigl(\ket{0}^{\otimes n}\bigr) = 1\bigr]
- \text{Pr}\bigl[\mathcal S^{\mathcal{G}_n}\bigl(\ket{0}^{\otimes n}\bigr) = 1\bigr] \Bigr| 
\leq \epsilon_2(n)\,.
$$
We conclude that the union of $\mathcal F_n$ with $\mathcal G_n$ (and assigning them each equal probability) is an unobfuscatable circuit family. This completes the proof of \expref{Theorem}{thm:cor}.
\qed
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%
\section{Quantum indistinguishability obfuscation}\label{sec:indistinguishability}
%%%%%%%%%%%%%%%%%%%%%%


%In this section, we analyze a different definition of quantum obfuscation, motivated by classical definitions established by Goldwasser and Rothblum~\cite{GR07}. As opposed to the black-box approach, these definitions assess the quality of an obfuscation in relative terms, e.g., as compared to other functionally-equivalent circuits (or, in the quantum case, states).  


\subsection{Definitions: indistinguishability, best-possible}
%%%%%%%%%%%%%%%%%%%%%%

We now consider quantum analogues of indistinguishability obfuscation. We will need some additional (but standard) notation and conventions for handling quantum circuits for CPTP maps, as well as generalized state ensembles. This is reviewed in \expref{Appendix}{app:CPTP}. As before, the interpreter $\mathcal J$ and the obfuscated state $\mathcal O(C)$ must be efficient, while the obfuscator $\mathcal O$ itself might not be. We assume that $\mathcal J$ has two registers: an advice register (where the obfuscated state is to be inserted), and an input register (where the input is to be inserted.) We will sometimes write $\mathcal J_{\rho}$ for the CPTP map family defined by $\mathcal J$ with the advice register initialized to $\rho$.

\begin{definition}\label{def:translator}
A \textbf{quantum translator} is a quantum algorithm $\mathcal O$ and a QPT $\mathcal J$ such that whenever $\mathcal C$ is a circuit ensemble and $C \in \mathcal C$ is an $n$-qubit circuit, 
\begin{enumerate}
\item (polynomial slowdown) $\mathcal O(C)$ has at most $\poly(n)$ qubits;
\item (functional equivalence) $\bigl\| \algo J_{\mathcal O(C)} - C \bigr\|_\diamond \leq \negl(n)$;
\end{enumerate}
\end{definition}

\begin{definition}\label{def:indistinguishability}
A \textbf{quantum statistical (resp., computational) indistinguishability obfuscator} is a quantum translator $(\mathcal O, \mathcal J)$ such that whenever $\mathcal C_S$ and $\mathcal D_S$ are functionally-equivalent circuit ensembles with $|C_s| = |D_s|$ for all $s \in S$, then $\mathcal O(\mathcal C_S)$ and $\mathcal O(\mathcal D_S)$ are statistically (resp., computationally) indistinguishable.
\end{definition}

An obfuscator which outputs circuit descriptions is a special case, where $\mathcal O(C)$ is a circuit and $\mathcal J$ is the universal circuit. The condition of equal length can be relaxed to any fixed polynomial (e.g., $|C_1|$ can be of length at most $|C_2|^2$.) To see that indistinguishability is a useful notion, we now show that it is equivalent to a semantic definition. Fixing a quantum translator $(\mathcal O, \mathcal J)$ defines a way to implement functionality via states. We then say that two state ensembles $\mathcal R_X$ and $\mathcal S_X$ are functionally equivalent if $\bigl\| \algo J_{\rho_x} - \algo J_{\sigma x} \bigr\|_\diamond \leq \negl(|x|)$ for all but finitely many $x \in X$, $\rho_x \in \mathcal R_X$ and $\sigma_x \in \mathcal S_X$. In this case, we will write $\mathcal R_X \cong_{\algo J} \mathcal S_X$. This allows us to compare the relative strengths of one obfuscated ensemble versus another, as follows.

\begin{definition}\label{def:best-possible}
A \textbf{quantum statistical (resp., computational) best-possible obfuscator} is a quantum translator $(\mathcal O, \mathcal J)$ such that for any QPT $\algo A$ there exists a QPT $\algo S$ with the following property: for every circuit ensemble $\mathcal C_X$ and any uniform state ensemble $\mathcal R_X$ which is functionally-equivalent to $\mathcal O(\mathcal C_X)$ and has same-size states\footnote{meaning that, for each $x \in X$, the corresponding states in the two ensembles have the same number of qubits.}, we have that $\algo A(\mathcal O(\mathcal C_X))$ and $\algo S(\mathcal R_X)$ are statistically (resp., computationally) indistinguishable.
\end{definition}

This definition captures the relative ``leakage'' of the obfuscated state ensemble: among all functionally-equivalent state ensembles (i.e., potential obfuscations), the best-possible obfuscation is the ensemble that leaks the least. Here we think of $\algo A$ as a ``learner'' which tries to learn something from the obfuscated ensemble, and $\algo S$ as a ``simulator'' which can learn the same thing as $\algo A$, but from any other functionally-equivalent ensemble.

\begin{proposition} Let $(\algo O, \algo J)$ be a polynomial-time quantum translator. Then $(\algo O, \algo J)$ is a quantum statistical (resp., computational) best-possible obfuscator if and only if it is a quantum statistical (resp., computational) indistinguishability obfuscator.
\end{proposition}
\begin{proof}
First, let $(\algo O, \algo J)$ be a best-possible obfuscator. Set $\mathcal A$ to be the trivial learner which implements the identity operator, and let $\mathcal S$  be the corresponding simulator. Let $\mathcal C$ and $\mathcal D$ be two functionally-equivalent circuit ensembles with same-size circuits. Note that their obfuscations are functionally-equivalent (i.e., $\algo O(\mathcal C) \cong_{\algo J} \algo O(\mathcal D)$) same-size ensembles. By two applications of the best-possible property (one on the left, and one on the right), we get
$$
\algo O(C) = \algo A(\algo O(C)) \approx \algo S(\algo O(D)) \approx \algo A(\algo O(D)) = \algo O(D)\,,
$$
where $\approx$ denotes the appropriate form of indistinguishability (statistical or computational.) Note that this direction did not require the obfuscator to be efficient.


For the other direction, let $(\algo O, \algo J)$ be an indistinguishability obfuscator. Given a learner $\algo A$, define a simulator $\algo S$ as follows. Let $(\mathcal C, \mathcal R)$ be a (circuit, ensemble) pair as in the best-possible definition. Since $\mathcal R$ is a uniform state ensemble, there is a corresponding circuit ensemble $\mathcal D$ for preparing it. Given a circuit $D \in \mathcal D$ and the corresponding circuit $J \in \algo J$ of the interpreter, we can then build a circuit $D \circ J$ which is functionally equivalent to the corresponding circuit $C \in \mathcal C$ (by the definition of a quantum translator.) Let $\mathcal {D \circ J}$ be the corresponding circuit family, and define $\algo S ( \mathcal R ) = \algo S ( \algo O ( \mathcal {D \circ J}))$. Now, by the indistinguishability property, $\algo O(\mathcal C) \approx \algo O (\mathcal {D \circ J})$, from which it follows that 
$\algo A( \algo O(\mathcal C)) \approx \algo A( \algo O(\mathcal {D \circ J})) = \algo S(\mathcal R).$
as desired.
\end{proof}


\subsection{Impossibility of statistical obfuscation}
%%%%%%%%%%%%%%%%%%%%%%

Recalling the following computational problems, and corresponding complexity-theoretic results.

\begin{problem} \textsf{\emph{Circuit distinguishability}}.\\
\indent Input: two quantum circuits $C$ and $D$; parameter $\epsilon > 0$. \\
\indent Promise: $\|C - D\|_\diamond$ is greater than $2 - \epsilon$ or less than $\epsilon$.\\
\indent Output: YES in the former case and NO in the latter.
\end{problem}

\begin{problem} \textsf{\emph{Quantum State Distinguishability}}.\\
\indent Input: $m$-qubit quantum circuits $C_0$ and $C_1$, positive integer $k \leq m$ and parameters $a,b$ with $a<b^2$.\\
\indent Promise: let $\rho_i = \tr_{(k+1, m)}[C_i\ket{0^m}\bra{0^m}C_i^\dagger]$; then $\|\rho_0 - \rho_1\|_\emph{tr}$ is greater than $b$ or less than $a$.\\
\indent Output: YES in the former case and NO in the latter.
\end{problem}

\begin{theorem}\label{thm:QCD}
\emph{\cite{RW05}} The problem \textsf{\emph{Circuit distinguishability}} is QIP-complete for every $\epsilon > 0$. 
\end{theorem}

\begin{theorem}\label{thm:QSD}
\emph{\cite{Watrous02}} The problem \textsf{\emph{Quantum State Distinguishability}} is QSZK-complete.
\end{theorem}

In the obfuscation setting, these two results imply the following.

\begin{theorem}
If there exists a poly-time quantum statistical indistinguishability obfuscator, then PSPACE $\subseteq$ QSZK.
\end{theorem}
\begin{proof}
We will actually show QIP $\subset$ BQP$^{\text{QSZK}}$; since BQP is contained in QSZK and QIP = PSPACE~\cite{JJUW10}, the result will follow. We will solve \textsf{Circuit distinguishability} using a subroutine that solves \textsf{Quantum State Distinguishability}. Given the classical descriptions of $C$ and $D$, we run the obfuscator $\algo O$ on both to get states $\algo O(C)$ and $\algo O(D)$. Now we apply the subroutine, and output its result.

Note that, if $C$ and $D$ are elements of a pair of functionally-equivalent circuit ensembles, then $\algo O(C)$ and $\algo O(D)$ will be indistinguishable and the subroutine will output YES. On the other hand, if $C$ and $D$ are far from being functionally equivalent, then there exists some input on which they differ significantly. It follows that $\algo O(C)$ and $\algo O(D)$ must be distinguishable; if they were not, then $\algo J_{\algo O(C)}$ and $\algo J_{\algo O(D)}$ would be functionally equivalent, contradicting the translator conditions in the definition of the obfuscator.
\qed
\end{proof}

In addition, we can prove an impossibility result for the case of statistical obfuscators which can only obfuscate unitary circuits. We first recall the \textsf{Identity Check} problem. Given an $m$-qubit state $\rho$ and indices $l, k \geq 0$, we let $\tr_{l,k} [\rho]$ denote the result of tracing out qubits $l$ through $k$ of $\rho$. We adopt the convention that nothing is traced out (i.e., $\tr_{l,k}[\rho] = \rho$) if $l > m$.

\begin{problem} \emph{\textsf{Identity Check}}.\\
\indent Input: an $n$-qubit unitary quantum circuit $C$ and parameters $a$,$b$ so that $b-a\geq 1/poly(n)$. \\
\indent Promise: $\min_\alpha \| C - e^{i \alpha} I \|$ is less than $a$ or greater than $b$.\\
\indent Output: YES in the former case and NO in the latter.
\end{problem}

\begin{theorem}\label{thm:ID}
\emph{\cite{JWB03}} The problem Identity Check is coQMA-complete. 
\end{theorem}

\begin{theorem}
If there exists a polynomial-time quantum statistical indistinguishability obfuscator for unitary circuits, then coQMA is contained in QSZK.
\end{theorem}
\begin{proof}
We will actually show coQMA $\subset$ BQP$^{\text{QSZK}}$; since BQP is contained in QSZK, the result will follow. Let $a$ and $b$ satisfy $b-a = 1 / \text{poly}(n)$. We will solve Identity Check using a subroutine that solves Quantum State Distinguishability. 

Let $C$ be the input, i.e., a classical description of an $n$-qubit quantum circuit. Create an identity circuit $D$ with an equal number of inputs as $C$, and of equal length to $C$. Let $O_C$ be a circuit that initializes a register with the classical state $\ket{C}$ containing the classical description of $C$, and applies the circuit of $\mathcal O$ which corresponds to the input length $|C|$. Likewise, let $O_D$ be a circuit that initializes a register with the classical state $\ket{D}$ containing the classical description of $D$, and applies the circuit of $\mathcal O$ which corresponds to the input length $|D| = |C|$. Note that, after tracing out ancillas, the outputs of these circuits are given by
$$
\tr_\text{anc.} \bigl[O_C\ket{0}\bra{0}O_C^\dagger\bigr] = \mathcal O(C)
\qquad \text{and} \qquad
\tr_\text{anc.} \bigl[O_D\ket{0}\bra{0}O_D^\dagger\bigr] = \mathcal O(D)\,.
$$
Now apply the subroutine for solving quantum state distinguishability to the pair $(O_C, O_D)$. If it says ``close'', we output YES; otherwise we output NO. Let's show that this has solved $(a, b)$-identity-check. Note that the states $\mathcal O(C)$ and $\mathcal O(D)$ must have the same number of qubits, and denote that number by $m$.
\begin{itemize}
\item \textbf{completness.} In this case, the obfuscated states satisfy $\|\mathcal O(C) - \mathcal O(D)\|_\text{tr} \leq \alpha$.  By the definition of the induced trace norm, this implies that $\|\mathcal J_{\mathcal O(C)}^n - \mathcal J_{\mathcal O(D)}^n\|_\diamond \leq \alpha$. By functional equivalence for $C$ and $D$ and the triangle inequality, it follows that $\|U_C - U_D\|_\diamond = \|U_C - I\|_\diamond \leq \alpha$, as desired.

\item \textbf{soundness.} In this case, the obfuscated states satisfy $\|\mathcal O(C) - \mathcal O(D)\|_\text{tr} \geq \beta$. We claim that this implies $\|U_C - U_D\|_\diamond > b$. Suppose this is not the case, i.e., that these operators are in fact close; then by the indistinguishability property, it would follow that $\mathcal O(C)$ and $\mathcal O(D)$ are close as well, a contradiction.
\end{itemize}
The above amounts to a BQP$^\text{QSZK}$ protocol for a coQMA-hard problem, thus placing coQMA in QSZK.
\qed
\end{proof}

\subsection{Application: quantum witness encryption}
%%%%%%%%%%%%%%%%%%%%%%

We now give an interesting application of the surviving case of quantum indistinguishability obfuscation, i.e., the computational variant.

The classical idea of witness encryption was first studied in~\cite{GGSW13}; its connection to indistinguishability obfuscation was first considered in~\cite{GGHRSW13}. In the quantum case, we set up the problem as follows. Suppose Alice wishes to encrypt a quantum state $\rho$, but not to a particular key or for a particular person; instead, the encryption is tied to a challenge question, and anyone that can answer the question correctly can decrypt the plaintext. The question will be of a particularly quantum nature: a correct answer will be a quantum state, e.g., the ground state of some Hamiltonian.

More formally, we consider a QMA language $L$, %, such as Quantum $3$SAT \cite{GN13}.  
and would like to enable Alice to encrypt her state $\rho$ using a particular problem instance $x$. %, in this case a Hamiltonian $H=\sum_{i=1}^r \Pi_{i}$, which is the sum of 3-local projectors that act on an $n$-qubit Hilbert space.  
If $x$ is a ``yes" instance, %i.e., if there exists a ground state with energy 0, 
then we'd like to allow Bob, who holds a witness state, to be able to decrypt Alice's message.  On the other hand, if $x$ is a no instance, then we demand that no QPT can distinguish between encryptions of any two quantum states  on the same number of qubits.  Interestingly, the definition says nothing about the case where $x$ is a yes instance but a witness is not known. While this may seem counterintuitive, the classical primitive has a number of natural applications (e.g., public-key encryption and identity encryption, see \cite{GGSW13}). It is likely that the quantum primitive has the same or similar applications, but we will not explore that question here.

We now show that witness encryption for QMA is possible, assuming the existence of a quantum computational-indistinguishability obfuscator. It is well-known (see, e.g.,~\cite{GN13}) that QMA contains languages $L$ which have a poly-time uniform circuit family $\mathcal C_L$ with completeness $1-2^{-\Omega(n)}$ and soundness $2^{-\Omega(n)}$. Given an instance $x$ of such a language $L$, and a quantum state $\rho$, consider the quantum circuit $Q_{x,\rho}(\sigma)$, which runs the appropriate circuit from $\mathcal C_L$ and outputs $\rho$ on accept, and $\ket{0^n}$ otherwise.  We claim the computational-indistinguishability obfuscation $\algo{O}(Q_{x,\rho})$ is a valid witness encryption for $L$ and $\rho$.  Correctness of decryption is clear, since the ability to provide a valid witness for $L$ allows Bob to use $\algo{O}(Q_{x,\rho})$ to obtain Alice's state $\rho$.  Of course, if $x$ is not in $L$, then no witness will suffice; more precisely, $\|Q_{x,\rho_1} - Q_{x, \rho_2}\| \leq 2^{-\Omega(n)}$ for any two quantum states $\rho_1, \rho_2$ on the same number of qubits. By the indistinguishability condition of \expref{Definition}{def:indistinguishability}, the obfuscation of $Q_{x,\rho_1}$ will be computationally indistinguishable from the obfuscation of $Q_{x,\rho_2}$.


%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}
%%%%%%%%%%%%%%%%%%%%%%

\subsection{Open problems}
%%%%%%%%%%%%%%%%%%%%%%

The central remaining open problem is whether quantum-mechanical means of obfuscation are possible, within the restricted framework placed by our results. In the classical setting, it is known that black-box obfuscation and statistical obfuscation are impossible; on the other hand, it is generally believed that computational-indistinguishability obfuscation can be achieved. In the quantum setting, on the other hand, much less is known. Although our results place some significant restrictions, several possibilities remain. For example, it is conceivable that \emph{information-theoretically secure black-box obfuscation} of a program is possible using quantum-mechanical means. Moreover, such a construction may even enable the user to use the obfuscated state to evaluate the program a polynomial number of times. Such an obfuscator would be tremendously powerful, and would be another example of quantum supremacy in the world of cryptography. It is difficult to imagine how such an obfuscation would function for arbitrary quantum programs (due to restrictions placed by the monogamy of entanglement); it is perhaps more reasonable to imagine it for classical functions. In that case, one could imagine using the state to perform the computation, then copying the (classical) output of the program, and restoring the obfuscated state by undoing the unitary circuit.

In the indistinguishability setting, constructions for obfuscating quantum programs are not known. It is conceivable that classical ideas (such as those in~\cite{GGHRSW13}) can be translated to the quantum setting. However, a key ingredient in~\cite{GGHRSW13} is fully-homomorphic encryption, which is yet to be achieved quantumly---although significant progress in this direction was recently made by Broadbent and Jeffery~\cite{BJ15}.

In terms of applications, our results raise another interesting question: what applications can we envision for obfuscators whose outputs are not cloneable or reproducible? Many of the standard applications are restricted in the case. On the other hand, one may be able to design applications where the inability to copy the obfuscator's output is a desired feature. In fact, one can imagine quantum obfuscators where the number of executions is highly limited in a manner analogous to one-time programs (see, e.g.,~\cite{BDG13}); this could also be of use in cryptographic settings.

\subsection*{Acknowledgements}
%%%%%%%%%%%%%%%%%%%%%%%

G.\,A. would like to thank Stacey Jeffery, Anne Broadbent and Florian Speelman for engaging discussions about obfuscation. G.\,A. was supported by a Sapere Aude grant of the Danish Council for Independent Research, the ERC Starting Grant "QMULT" and the CHIST-ERA project "CQC". B.\,F. would like to thank Brad Lackey, Daniel Apon and Jonathan Katz for helpful conversations.  This work was supported by the Department of Defense.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliography{QuantumCrypto}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Quantum-secure primitives}\label{app:primitives}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Here we give definitions of quantum-secure one-way functions and pseudorandom functions.

\begin{definition}\label{def:quantum-secure-owf}
A PT-computable function $f:\{0,1\}^* \rightarrow \{0, 1\}^*$ is a quantum-secure one-way function (qOWF) if for every QPT $\algo A$, 
$$
\emph{Pr}_{x \inrand \{0, 1\}^n} \left[\algo A (f(x), 1^n) \in f^{-1}(f(x)) \right] \leq \negl(n)\,,
$$
where the probability is taken over $x \inrand \{0, 1\}^n$ as well as the measurements of $\algo A$.
\end{definition}

\begin{definition}\label{def:quantum-secure-prf}
A PT-computable function family $f_k : \{0,1\}^n \rightarrow \{0, 1\}^m$ is a quantum-secure pseudorandom function (qPRF) if for every QPT $\algo A$, 
$$
\left|\prob_{k \inrand \{0, 1\}^n} [\algo A^{f_k}(1^n) = 1] - \prob_{g \inrand \mathcal F_{n, m}}[ \algo A^g(1^n) = 1]\right|
\leq \negl(n)\,,
$$
where $\mathcal F_{n, m}$ denotes the space of all functions from $\{0,1\}^n$ to $\{0,1\}^m$.
\end{definition}

A general encryption scheme for quantum states is defined as follows.

\begin{definition}\label{def:encryption-scheme}
A symmetric-key quantum encryption scheme is a triple of QPTs:
\begin{itemize}
\item (key generation) $\KeyGen : 1^n \longmapsto k \in \{0, 1\}^n$;
\item (encryption) $\Enc_k : \states (\mathcal H_m) \longrightarrow \states (\mathcal H_c)$;
\item (decryption) $\Dec_k : \states (\mathcal H_c) \longrightarrow \states (\mathcal H_m)$;
\end{itemize}
where $m$ and $c$ are polynomial functions of $n$, and the QPTs satisfy $\| \Dec_k \circ \Enc_k - \one_m \|_\diamond \leq \negl(n)$ for all $k \in \emph{\supp}\,\KeyGen(1^n)$.
\end{definition}

Public-key quantum encryption schemes (with classical keys) are defined in an analogous manner~\cite{BJ15}. 



%%%%%%%%%%%%%%%%%%%%%%
\section{Applications of black-box obfuscation, with proofs}\label{app:proofs}
%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Quantum-secure one-way functions.}
%%%

We now prove the following.

\begin{prop}
If there exists a classical probabilistic algorithm which is a (perfect) quantum black-box obfuscator, then quantum-secure one-way functions exist.
\end{prop}
\begin{proof}
The proof is essentially the same as that of Lemma 3.8 in \cite{BGIRSVY12}. For all $a \in \{0, 1\}^n$ and $b \in \{0, 1\}$, we define 
$$
U_{a, b} : \ket{x,\, y} \longmapsto
\begin{cases}
\ket{a,\, y \oplus b} &\text{ if } x = a;\\
\ket{x,\, y} &\text{ otherwise}.
\end{cases}
$$
Define a function $f : \{0, 1\}^* \rightarrow \{0, 1\}^*$ by $f(a, b, r) = \algo O_r(U_{a, b})$ where $\algo O$ is the obfuscator\footnote{For simplicity of notation, we omit $\algo J$ and assume $f(a, b, r) = \algo O_r(U_{a, b})$ is a classical circuit for $U_{a, b}$.} as in the hypothesis, and $\algo O_r$ denotes the same algorithm, but with randomness coins initialized to $r$. Clearly, inverting $f$ requires computing $b$ from $\algo O_r(U_{a, b})$. Moreover, with only black-box access to $U_{a, b}$ (for uniformly random $a, b$) the probability of correctly outputing $b$ in polynomial time is at most $1/2 + \negl(n)$.  By the black-box property of $\mathcal O$, we then have
\begin{align*}
\prob_{a, b} [ A(f(a, b, r)) = b] 
&= \prob_{a, b} [ A(\mathcal O_r(a, b)) = b ]
\leq \prob_{a, b} \left[ S^{U_{a, b}}(1^n) = b\right] + \negl(n)\\
&\leq \frac{1}{2} + \negl(n)\,.
\end{align*}
\qed
\end{proof}


\paragraph{Private-key encryption for long messages.}
%%%

First recall the definitions.
$$
V_{r, k} : \ket{x,\, y} \longmapsto
\begin{cases}
\ket{x,\, P_r^\dagger y} &\text{ if } x = k;\\
\ket{x,\, y} &\text{ otherwise},
\end{cases}
$$
Next, recall the scheme.
\begin{itemize}
\item $\KeyGen(1^n)$: output $k \inrand \{0, 1\}^n$;
\item $\Enc_{k}(\rho)$: choose $r \inrand \{0, 1\}^{2\,l(n)}$; output $P_r \rho P_r^\dagger \otimes \algo O(V_{r, k})$;
\item $\Dec_{k}(\sigma \otimes \tau)$: output  the second register of $\algo J(\tau \otimes \ket{k}\bra{k} \otimes \sigma)$.
\end{itemize}
To check correctness, we apply the functionality-preserving property of the obfuscator. A decryption of a valid encryption with the same key yields
$$
\Dec_k (\Enc_k (\rho))  
= \tr_1 \left[\algo J(\algo O(V_{r, k}) \otimes \ket{k}\bra{k} \otimes P_r \rho P_r^\dagger)\right] \\
= \tr_1 \left[U_{r, k} (\ket{k}\bra{k} \otimes P_r \rho P_r^\dagger) V_{r, k}^\dagger\right] \\
 = \rho
$$
as desired. We argue briefly that the scheme satisfies semantic security, which is equivalent to IND~\cite{ABFGSS16}. Let $\algo A$ be a SEM adversary; we are charged with describing a simulator $\algo A'$. By the black-box property, $\algo A$ on input $\Enc_k(\rho)$ can be simulated by an adversary $\algo S$ who receives $P_r \rho P_r^\dagger$ and only queries $V_{r, k}$ as a black box. We note that, since $r$ is selected uniformly at random, and the plaintext and the obfuscated circuit are independent, we do not require the obfuscator to be secure in the presence of auxiliary information. Indeed, we can rewrite $P_r \rho P_r^\dagger = P_r' \rho' P_r'^\dagger$ for any other $r'$ (and some $\rho'$) and this does not change the execution of $\algo A$ or $\algo S$. By a Grover lower bound, $\algo S$ will succeed at distinguishing its oracle from the identity with at most negligible probability. Given this, the input of $\algo S$ simply appears maximally mixed. We can thus simply define the simulator $\algo A'$ to execute $\algo A$ on $(\one/d) \otimes \mathcal O(\one)$, regardless of the plaintext.


\paragraph{Public-key encryption from private-key encryption.}
%%%

Recall that $\Pi = (\KeyGen, \Enc, \Dec)$ is a symmetric-key quantum encryption scheme with classical keys $\Pi' = (\KeyGen', \Enc', \Dec')$ is the public-key scheme whose public key is $\algo O(\Enc_k)$.

We argue that, if $\Pi$ satisfies SEM-CPA (see ~\cite{ABFGSS16}) then $\Pi'$ satisfies SEM (for public-key schemes.) A $\Pi'$ SEM adversary $\algo A$ receives the public key $\algo O(\Enc_k)$ and a state
$$
\sigma_{AB} := [(\Enc_k)_A \otimes \one_B]\rho_{AB}
$$
which contains an encryption of the plaintext in register $A$, and a register $B$ of side information about the plaintext. Assume there exists such an $\algo A$, for which no simulator $\algo S$ (receiving only the public key and register $B$) exists. By black-box obfuscation with auxiliary information, there exists a QPT $\algo A_0^{\Enc_k}$ which simulates\,\footnote{Here one must check that it is sufficient to consider SEM adversaries which output predicates.} $\algo A$ on input $\sigma_{AB}$ and interacts with the public key in a black-box manner. Note that $\algo A_0$ is a valid (but perhaps not successful) SEM-CPA adversary against $\Pi$ : by functional equivalence of $\algo O$, the CPA oracle for $\Pi$ is equivalent to the oracle $\algo A_0$ expects. We claim that $\algo A_0$ (with the same plaintext, side information, and objective predicate as $\algo A$) has no simulator. For a contradiction, suppose $\algo S_0$ was such a simulator. We can then build a simulator $\algo S$ for $\algo A$ simply by running $\algo S_0$ and answering its CPA queries using the public key $\algo O(\Enc_k)$. We conclude that $\Pi'$ satisfies SEM, and thus also IND.

%%%%%%%%%%%%%%%%%%%%%%
\section{Proof of Theorem 8}\label{app:proof-theorem-8}
%%%%%%%%%%%%%%%%%%%%%%
We now return to the proof of \expref{Theorem}{thm:single-impossibility}, and show how to extend the above proof to the case where the obfuscator outputs reusable quantum states.

\begin{proof} (of \expref{Theorem}{thm:single-impossibility})
Our proof will still use the same distribution $\mathcal D_{a, b}$ over circuits, which were provided by \expref{Lemma}{lemma-circuitdistribution} and described above, but with some slight modifications. The goal will still be to take two copies of $\algo O(C_0)$ for any circuit $C_0$ sampled from that distribution, and give an algorithm $\algo A$ that can ``execute one copy on the other.'' This will enable us to distinguish if $C_0$ is from the distribution $\mathcal F_n$, or the distribution $\mathcal G_n$ (just as above), a task which is impossible with only black-box access.

However, executing one copy of $\algo O(C_0)$ on another is now somewhat more complicated, due to the fact that we no longer have explicit circuit descriptions in hand, and must instead use the interpreter $\algo J$ (with some register initialized to $\algo O(C_0)$) whenever we want to run $C_0$. To do this, we will need to describe a new distribution $\mathcal D_{a, b}'$ of circuits, closely related to the distribution $\mathcal D_{a, b}$ from \expref{Lemma}{lemma-circuitdistribution}.

\textbf{Attempt 1.~}To warm up, a first attempt at describing $\algo A$ and the modified circuits $D_{a, b}'$ from the distribution $\mathcal D_{a, b}'$ is as follows. First, we simply define $D_{a, b}'$ to be a composition of circuits which simply output both $a$ and $b$. Set $C_0 = C \# D_{a, b}'$, and suppose that inputting $\ket{0}$ in the first register executes the first circuit in the combination, while $\ket{1}$ executes the second circuit in the combination. The algorithm $\algo A$ is in possession of two copies of $\algo O(C_0)$. It performs:
\begin{enumerate}
\item run $\algo J ( \algo O(C_0) \otimes \ket{1} \ket{0^n})$ to retrieve $\ket{a} \ket{b}$ (by functional equivalence of $\algo O$);
\item run $\algo J( \algo O(C_0) \otimes \ket{0} \ket{a})$ (now using the other copy of $\algo O(C_0)$);
\item compare the result to $\ket{b}$.
\end{enumerate}
This does exactly what we want, except of course that the black-box simulator $\algo S$ will also be able to retrieve $a$ and perform this experiment. Our valiant attempt failed.

\textbf{Attempt 2.~}Undeterred, we now try a more sophisticated approach, returning to the idea of encryption and homomorphic execution. We now ask that (as before) $\mathcal D_{a, b}'$ outputs an encryption $\Enc(a)$ of $a$ (when given the flag $A$), implements a $\Homorcl$ oracle (when given the flag $H$), and checks if the input is $\Enc(b)$ (when given the flag $B$). We again set $C_0 = C \# D_{a, b}'$ and give $\algo A$ two copies of $\algo O(C_0)$; for convenience we denote them $\algo O(C_0)$ and $\algo O(C_0)'$. Now, $\algo A$ performs: 
\begin{enumerate}
\item run $\algo J \bigl( \algo O(C_0) \otimes [\ket{1A} \otimes \ket{0^n}]\bigr)$ to retrieve $\Enc(a)$;
\item run $\algo J \bigl( \algo O(C_0) \otimes [\ket{1H} \otimes \algo O(C_0)' \otimes \ket{0} \otimes \Enc(a)]\bigr)$ to ``homomorphically run $C$'';
\item run $\algo J \bigl( \algo O(C_0) \otimes [\ket{1B} \otimes \rho]\bigr)$ where $\rho$ is the output of the previous step; output the result.
\end{enumerate}
The first and last step are largely self-explanatory: we start with the encryption of $a$, and check at the end that we have the encryption of $b$. What happened in the second step? We tried to homomorphically evaluate\footnote{Selecting $C$ was done by passing the bit flag $\ket 0$ into the control register.} $C$ on $\Enc(a)$. By functional equivalence of $\algo O$, we executed the first copy of $C_0$ on input $\ket{1H} \otimes \algo O(C_0)' \otimes \Enc(a)$; this specifies that $D_{a, b}'$ should run the $\Homorcl$ oracle with input $\mathcal O(C_0)' \otimes \Enc(a)$. To make this sensible, we can redefine $\Homorcl$ to accept two registers, and homomorphically evaluate the appropriate circuit of $\algo J$; the result is that, whenever $\Homorcl$ is called on $\mathcal O(C) \otimes \Enc(z)$ for a circuit $C$ and state $z$, the output is $\Enc(C(z))$.

This attempts looks like it succeeds, but there is a disastrous flaw: $\Homorcl$ must now accept inputs with at least as many qubits as $\algo O(C_0)$, which is significantly bigger than the circuit description allowed for $\Homorcl$ itself (since it is a part of $D_{a, b}'$ and hence also of $C_0$).

\textbf{Attempt 3.~} In the final attempt, we will repair the flaw of Attempt 2. The key is to again offload some of the execution, but this time from the $\Homorcl$ oracle to the main algorithm $\algo A$. More precisely, we will expand step (2) in Attempt 2, and execute it gate-by-gate. In this iteration, $\Homorcl$ is back to its original version, and is used only to apply two-qubit gates. It accepts $n$ input qubits, decrypts them, applies the desired gate (as specified in another register), and then re-encrypts. In addition, will also expand $D_{a, b}'$ to provide an $\Enc$ oracle (when given the flag E); we can do this for free, by equation \eqref{eq:hom-gap} in \expref{Lemma}{lemma-circuitdistribution}. The final algorithm $\algo A$ will proceed as follows. Here we have let $m$ denote the number of qubits of $\algo O(C_0)'$, and we let $J_m$ be the circuit of $\algo J$ for executing $m$-qubit obfuscated states.
\begin{enumerate}
\item run $\algo J \bigl( \algo O(C_0) \otimes [\ket{1E} \otimes \algo O(C_0)'_{(k)}]\bigr)$ for all $k \in [m]$, to encrypt all qubits of $\algo O(C_0)'$; 
\item run $\algo J \bigl( \algo O(C_0) \otimes [\ket{1A} \otimes \ket{0^n}]\bigr)$ to retrieve $\Enc(a)$;
\item let $j = 0$ and let $\sigma_j := \Enc(a)$;
\item let $G_j$ be the $j$th gate in the description of $J_m$;
\begin{enumerate}
\item let $s, t$ be the qubits $G_j$ acts on; assume $s$ is a qubit of $\algo O(C_0)'$ and $t$ is a qubit of $\sigma_j$;\footnote{This assumption is only made for simplicity of the algorithm description; the other possibilities are similar.}
\item set $\sigma_{j+1} = \algo J \bigl( \algo O(C_0) \otimes [\ket{1H} \otimes \ket{G_j, s, t} \otimes \Enc(\algo O(C_0)'_{(s)}) \otimes \sigma_j]\bigr)$;\,\footnote{The notation $\algo O(C_0)'_{(s)}$ is meant to indicate that only the $s$-th qubit of that state is to be placed in the input register.}
\item if $j = |J_m|$, continue; otherwise increment $j$ by $1$ and go to step 4.
\end{enumerate}
\item run $\algo J \bigl( \algo O(C_0) \otimes [\ket{1B} \otimes \sigma_j]\bigr)$ and output the result.
\end{enumerate}
A few remarks are in order. First, the reusability of the state $\algo O(C)$ was crucial in our ability to repeatedly execute the $\Homorcl$ oracle in step 4.(b). Second, one checks that by the functional equivalence of the obfuscator and the definition of the $\Homorcl$ oracle, if $C_0 = C_{a, b} \# D_{a, b}'$ then the state $\sigma_j$ when step 5. is reached will indeed be $\Enc(b)$. Third, note that the ``compactness'' issue of $\Homorcl$ from Attempt 2 has been resolved, and the input to $C_0$ in step 4.(b) is now of size $n$ (plus a constant.) 

Finally, despite all of the difficulties in defining the algorithm $\algo A$ appropriately, the hardness of the corresponding search problem for the black-box simulator $\algo S$ is essentially unchanged from the proof of \expref{Theorem}{thm:cor}. The only difference is that $D_{a, b}'$ now also provides an encryption oracle; the encryption scheme we selected is certainly secure in this setting. 

To finish the proof, we again build a circuit family by choosing $C_{a, b} \# D_{a, b}'$ or $I_{2n} \# D_{a, b}'$, each with equal probability, for random $a$ and $b$. By the above arguments, this circuit family is unobfuscatable. This concludes the proof of \expref{Theorem}{thm:single-impossibility}.
\end{proof}

\section{Notation on CPTP circuits and state ensembles}\label{app:CPTP}
%%%%%%%%%%%%%%%%%%%%%%

For our discussions on indistinguishability obfuscation, we modify the notations of \expref{Section}{sec:notation} slightly, as follows. First, henceforth we take the point of view that any quantum circuit $C$ can include unitary gates \emph{as well as measurement gates and instructions for adding/discarding qubits.} We overload notation so that $C$ denotes both the circuit itself (i.e., a classical description of a set of wires and gates) as well as the CPTP map itself. 

Second, we allow our ensembles to be indexed by infinite sets of strings rather than the natural numbers. As before, we will denote ensembles by italicized capital letters (and optionally place the indexing set in the subscript.) Elements of the ensemble will be denoted by the corresponding non-italicized capital letter (optionally, with the index in the subscript.) So, for example, we may write $\mathcal C_S := \{C_s : s \in S\}$. Just as in the single-circuit case, we will overload this notation for circuit ensembles and use it to also refer to the corresponding family of CPTP maps. We will need one new definition in this context: given two circuit ensembles $\mathcal C_S$ and $\mathcal D_S$, we say that $\mathcal C_S$ is \textbf{functionally equivalent} to $\mathcal D_S$ (denoted $\mathcal C_S \cong \mathcal D_S$) if the circuits themselves are functionally equivalent, i.e., if $\|C_s - D_s\|_\diamond \leq \negl(|s|)$ for all $s \in S$. 

We will also now need to handle infinite collections of states. We thus define a \textbf{state ensemble} to be an infinite collection $\{\rho_x : x \in X\}$ of density operators indexed by some set $X \subset \{0, 1\}^*$, such that $\rho_x \in \states(\mathcal H_{p(|x|)})$ where $p$ is bounded by some fixed polynomial function. We remark that a circuit ensemble is a special case of a state ensemble, where each state is a classical string describing wires, gates, and so on. A \textbf{uniform state ensemble} will be a state ensemble $\{\rho_x : x \in X\}$ together with a uniform circuit ensemble $\{C_x : x \in X\}$ such that $\rho_x = C_x |0^m\rangle$ for appropriately chosen $m$. We remark that a QPT is defined by choosing a uniform circuit ensemble, and that the set of possible outputs of a QPT are a uniform state ensemble. In particular, if $\mathcal S$ is a state ensemble and $\algo A$ is a QPT, then (ignoring some uninteresting bookkeeping) we may write $\algo A(\mathcal S)$ to denote the state ensemble that results from running $\algo A$ on inputs from $\mathcal S$. Note that if $\mathcal S$ is uniform, then $\algo A(\mathcal S)$ is also uniform.

Next, we consider three different notions of distinguishability for state ensembles, in order of decreasing power. We will write $\mathcal R \approx \mathcal S$ to indicate that $\mathcal R$ and $\mathcal S$ are indistinguishable state ensembles; the type of indistinguishability should be clear from context. Let $\mathcal R = \{\rho_x : x \in X\}$ and $\mathcal S = \{\sigma_x : x \in X\}$ be two state ensembles. We say that $\mathcal R$ and $\mathcal S$ are \textbf{perfectly indistinguishable} if $\rho_x = \sigma_x$ for every $x \in X$. While this is an unnatural notion of indistinguishability for general quantum states, it is more reasonable (and is easy to test for individual cases) if $\rho_x$ and $\sigma_x$ happen to all be classical. A weaker notion is \textbf{statistical indistinguishability}, which demands that $\|\rho_x - \sigma_x\|_\text{tr} \leq \poly(|x|)$ for all but finitely many $x \in X$. In the weakest notion we will consider, we say that $\mathcal R$ and $\mathcal S$ are \textbf{computationally indistinguishable} if for every QPT $\algo A$, $\left|\Pr[\algo A(\rho_x) = 1] - \Pr[\algo A(\sigma_x) = 1]\right| \leq \negl(|x|)$
for all but finitely many $x$; here the probabilities are taken over the coins and measurements of $\algo A$. One may also consider a non-uniform version of the above definition, in which $\algo A$ also ranges over non-uniform circuit families, and is allowed access to an auxiliary state ensemble $\{\xi_x : x \in X\}$. All of our results hold (with appropriate adjustments) for both the uniform and the non-uniform setting; we will focus on the uniform setting for convenience. 

\end{document}