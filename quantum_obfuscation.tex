\documentclass[11pt]{article}

\usepackage{color}
\usepackage{amsmath,amsthm,amsbsy,amssymb,dsfont}
\usepackage{mathtools}
\usepackage[colorlinks=true,urlcolor=webblue,linkcolor=webgreen,filecolor=webblue,citecolor=webgreen,pdfpagemode=UseOutlines,pdfstartview=FitH,pdfpagelayout=OneColumn,bookmarks=true]{hyperref}
\usepackage{fullpage}
\usepackage{doi}
\usepackage[numbers]{natbib}
\usepackage{microtype}
\usepackage{xspace}
\usepackage{tikz}
\usepackage{bigints}
\usepackage{mathptmx}
\usepackage{palatino}
\usepackage{eucal}

\hypersetup{pdfauthor={Gorjan Alagic}}

\definecolor{webgreen}{rgb}{0,.5,0}
\definecolor{webblue}{rgb}{0,0,.5}

\DeclareMathOperator{\tr}{Tr}
\DeclareMathOperator*{\Exp}{\mathbb{E}}

\numberwithin{equation}{section}

\newtheorem{theorem}{Theorem}
\newtheorem{prop}{Proposition}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{conjecture}{Conjecture}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}{Definition}
\newtheorem{question}{Question}

%% Define a satisfactory mathbb 1.
\newcommand{\one}{\mathds 1}
\renewcommand{\vec}[1]{\mathbf{#1}}
\newcommand{\D}{\mathsf{D}}
\DeclareMathOperator{\Ind}{Ind}
\DeclareMathOperator{\End}{End}
\newcommand{\op}{\operatorname{op}}
\newcommand{\opn}{\operatorname}
\newcommand{\inter}{\mathfrak{I}}
\newcommand{\eqdef}{\triangleq}
\newcommand{\E}{\mathbb{E}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\U}{\textsf{U}}
\newcommand{\outerprod}[2]{|#1\rangle\langle #2|}
\newcommand{\innerprod}[2]{\langle #1, #2\rangle}
\newcommand{\ket}[1]{|#1\rangle}
\newcommand{\bra}[1]{\langle #1|}
\newcommand{\Hom}{\operatorname{Hom}}
\newcommand{\GL}{\textsf{GL}}
\newcommand{\SU}{\textsf{SU}}


\newcommand{\expref}[2]{\texorpdfstring{\hyperref[#2]{#1~\ref{#2}}}{#1~\ref{#2}}}

\newcommand{\revise}[1]{}
\renewcommand{\vec}[1]{\mathbf{#1}}

\newcommand{\band}[1]{\mathcal{#1}}
\newcommand{\error}{\varepsilon}
\newcommand{\recon}{R}
\newcommand{\idim}{\dim_{\opn{I}}}

%%% added by GA  Sept 2015
\newcommand{\algo}{\mathcal}
\newcommand{\negl}{\opn{negl}}
\newcommand{\KeyGen}{\ensuremath{\mathsf{KeyGen}}\xspace}
\newcommand{\Enc}{\ensuremath{\mathsf{Enc}}\xspace}
\newcommand{\Dec}{\ensuremath{\mathsf{Dec}}\xspace}
\newcommand{\inrand}{\in_R} 
\newcommand{\prob}{\opn{Pr}}
\newcommand{\states}{\mathfrak D}
\newcommand\supp{\textbf{supp}}
%%%

\newcommand{\ga}[1]{{ \textcolor{purple}{(Gorjan:  #1)}}{}}

\bibliographystyle{plainnat}
\begin{document}


\title{Quantum obfuscation}
\author{Gorjan Alagic and Bill Fefferman}
\maketitle
\abstract{\ga{just a placeholder:} We consider the question of obufscating quantum programs. We consider a few formalizations: black-box, indistinguishability, and best-possible. We prove that black-box obfuscation of quantum circuits is impossible. This result leaves open one possibility: obfuscating a quantum circuit into a quantum state (but only once; the presence of multiple obfuscations are impossible in general.) We also show that indistinguishability and best-possible obfuscation are equivalent, and that they are impossible to satisfy in the exact or statistical case.} Our black-box impossibility proof requirers a notion of encrypting quantum states with computational assumptions; we show that this can be done in a way that is secure against non-adaptive chosen-ciphertext attacks, provided quantum-secure one-way functions exist. 

\newpage
\tableofcontents
\newpage


%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
%%%%%%%%%%%%%%%%%%%%%%

Things to cover:
\begin{itemize}
\item data encryption is central to modern classical crypto;
\item it's reasonable to ask if there is also program encryption;
\item at the same time, the appearance of quantum computers has complicated everything;
\item we ask: 
\begin{itemize}
\item can one obfuscate quantum programs? 
\item what are some reasonable definitions of what this even means?
\item let's say we \emph{can} obfuscate quantum programs; what does this buy us?
\item in order to properly address these question, we also need to address encryption of quantum data with computational assumptions (where only info-theoretic has been considered before); but the main part of this work will appear in another paper, etc.
\end{itemize}
\end{itemize}

\subsection{Background}
%%%%%%%%%%%%%%%%%%%%%%

Things to cover:

\begin{itemize}
\item classical work on obfuscation
\begin{itemize}
\item original VBB impossibility result
\item original indistinguishability and best-possible paper
\item recent work on candidate IO schemes, all the nice applications, and a brief summary of latest work 
\end{itemize}
\item quantum work on obfuscation
\begin{itemize}
\item Scott's semi-grand challenge question
\item Mosca and Stebila suggestion of obfuscating circuits to get quantum money
\item our paper on "partial-indistinguishability."
\end{itemize}
\end{itemize}

\subsection{Summary of results}
%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Quantum black-box obfuscation}
%%%%

\begin{enumerate}
\item define quantum black-box obfuscation
\item show several applications:
\begin{itemize}
\item classical algorithm for it implies quantum-secure OWFs;
\item quantum obfuscator implies IND-CPA SKE for quantum states;
\item obfuscator + qOWFs implies IND-CPA PKE for quantum states;
\item obfuscator (plus what else?) implies QFHE;
\item emphasize that all these encryption schemes also work for \emph{classical data}, but may require quantum ciphertexts (and hence also quantum encryption and decryption algorithms);
\item obfuscator implies quantum money (details?);
\end{itemize}
\item impossibility results:
\begin{itemize}
\item two-state black-box obfuscation impossible
\item obfuscation with cloneable outputs impossible
\end{itemize}
\item as part of the impossibility result, we will need the existence of IND-CCA1 secure quantum encryption schemes; so we define those and prove that they exist; this appears to be new as well.
\end{enumerate}

\subsubsection{Quantum indistinguishability obfuscation}
%%%%

\begin{enumerate}
\item define quantum indistinguishability obfuscation and quantum best-possible obfuscation;
\item three variants: perfect, statistical, computational;
\item applications:
\begin{itemize}
\item witness encryption for QMA
\item classically we also get functional encryption (cite) and many more applications through the very successful ``punctured programs'' technique (cite); we suspect that these can be adapted to the quantum case, but leave them open for now;
\end{itemize}
\item proved each indistinguishability variant is equivalent to its corresponding best-possible variant;
\item proved impossibility of perfect and statistical indistinguishability obfuscators.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%
\section{Preliminaries}
%%%%%%%%%%%%%%%%%%%%%%

\subsection{Notation etc.}
%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}
\item PT, PPT, QPT, etc. (might be partially covered in the next subsection)
\item the notation $x \inrand \{0,1\}^n$.
\item $\mathcal H_m$ is the space of $m$-qubit pure states, and $\states(\mathcal H_m)$ is the corresponding space of density operators
\item $\one_m$ is the $m$-qubit identity.
\end{itemize}

\subsection{Probabilistic and quantum algorithms}
%%%%%%%%%%%%%%%%%%%%%%

We briefly review some terminology regarding probabilistic and quantum algorithms. For precise definitions, refer to \cite{ccreference}. As is standard, by a probabilistic classical algorithm $\mathcal A$ we will mean an infinite family of probabilistic classical circuits, at least one for each possible input size~\footnote{when there's more than one circuit for a given input size, there should be some efficient way to decide which inputs of that size are assigned to which circuit.}. When the input register is initialized with the string $x$ and the randomness register is initialized with the string $r$, the output of the relevant circuit will be denoted by $\mathcal A(x; r)$. We will simply write $\mathcal A(x)$ when the randomness register should be initialized with a uniformly random string.

A quantum algorithm $\mathcal Q$ will mean an infinite family of quantum circuits, at least one for each possible input size. For each circuit, the qubits it acts on are divided into an input register and an ancilla register; the former is initialized in some input state $\sigma$ and the latter is always initialized in the $\ket{0}$ state. All of the qubits are also divided into an output register and a garbage register; it is always assumed that the garbage register is traced out after the circuit is applied. The (possibly mixed) state which remains in the output register is called the output of the algorithm, and is denoted $\mathcal Q(\sigma)$.

We will sometimes also allow for algorithms which are allowed to mix probabilistic and quantum computation in a straightforward way: a classical probabilistic circuit first uses a string of classical randomness to decide which quantum circuit to run on the given quantum input state, and the chosen quantum circuit is then executed. We will call such algorithms probabilistic-quantum and refer to output states with or without specified randomness as above. The computational power of such algorithms can already be captured by quantum algorithms alone by reversibly implementing the classical pre-processing; the classical probabilistic mixtures are then absorbed into the density operator of the quantum state as it evolves under the quantum circuit. However, the distinction does have a difference: the final density operator outputted by the resulting quantum algorithm could exhibit some important property which is \emph{not} true for any of the outputs of the original probabilistic-quantum algorithm. We will discuss an explicit example later.

An algorithm will be referred to as polynomial-time (or efficient) if all of the relevant circuit families are polynomial-time uniform~\cite{ccreference}; this applies to all classes of algorithm discussed above.


%%%%%%%%%%%%%%%%%%%%%%
\section{Quantum encryption}\label{sec:encryption}
%%%%%%%%%%%%%%%%%%%%%%

\subsection{Quantum-secure pseudorandomness}
%%%%%%%%%%%%%%%%%%%%%%

We begin with two primitives for encryption: quantum-secure one-way functions, and quantum-secure pseudorandom functions. These are both classical, efficiently computable functions which are in some sense resistant to quantum analysis. In the case of one-way functions, we demand that inversion is hard; in the case of pseudorandom functions, we demand that distinguishing from perfectly random functions is hard.

\begin{definition}\label{def:quantum-secure-owf}
A PT-computable function $f:\{0,1\}^* \rightarrow \{0, 1\}^*$ is a quantum-secure one-way function (qOWF) if for every QPT $\algo A$, 
$$
\emph{Pr}_{x \inrand \{0, 1\}^n} \left[\algo A (f(x), 1^n) \in f^{-1}(f(x)) \right] \leq \negl(n)\,,
$$
where the probability is taken over $x \inrand \{0, 1\}^n$ as well as the measurements of $\algo A$.
\end{definition}

\begin{definition}\label{def:quantum-secure-prf}
A PT-computable function family $f_k : \{0,1\}^n \rightarrow \{0, 1\}^m$ is a quantum-secure pseudorandom function (qPRF) if for every QPT $\algo A$, 
$$
\left|\prob_{k \inrand \{0, 1\}^n} [\algo A^{f_k}(1^n) = 1] - \prob_{g \inrand \mathcal F_{n, m}}[ \algo A^g(1^n) = 1]\right|
\leq \negl(n)\,,
$$
where $\mathcal F_{n, m}$ denotes the space of all functions from $\{0,1\}^n$ to $\{0,1\}^m$.
\end{definition}

Classically, one-way functions are the fundamental primitive underpinning encryption. A series of basic results shows that one-way functions can be turned into pseudorandom functions, which can then be used for defining probabilistic encryption schemes. This series of results carries over to the quantum-secure case without much of a change (although some proofs are somewhat more involved.) For example, it is known how to construct qPRFs from qOWFs.

\begin{theorem}\label{thm:qOWF-implies-qPRF}
If quantum-secure one-way functions exist, then so do quantum-secure pseudorandom functions.
\end{theorem}
\begin{proof} (Sketch.) It is folklore that the well-known H{\aa}stad et al. result that pseudorandom generators can be constructed from any one-way function~\cite{HILL99} carries over to the quantum-secure case. Roughly speaking, the reasoning is that the reduction in the proof is done in a ``black-box'' way, i.e., only by feeding inputs into the adversary and then analyzing the resulting outputs. The quantum-secure case then simply involves replacing PPTs with QPTs in the appropriate places. Proving that the standard GGM construction~\cite{GGM86} of PRFs from pseudorandom generators is still secure in the setting of quantum adversaries is more involved; this was established by Zhandry~\cite{Zhandry2012}.
\end{proof}

\subsection{Symmetric-key encryption of quantum states}
%%%%%%%%%%%%%%%%%%%%%%

Some of our proofs in later sections will require a notion of encryption of quantum states with computational assumptions. Interestingly, this topic has not received significant attention as yet. In what follows, we describe the basic idea and prove a new result that we will need later. A much more thorough treatment of this topic will be given in an upcoming work~\cite{ABGFSS15}. Ciphertext indistinguishability for quantum encryption was also recently considered in~\cite{BJ15}.

It is well-known how to encrypt quantum states with information-theoretic security, via the so-called quantum one-time pad. To encrypt a single-qubit state $\rho$, we choose two classical bits at random, use them to select a random Pauli matrix $P \in \{\one, X, Y, Z\}$, and perform $\rho \mapsto P \rho P^\dagger$. To encrypt an $n$-qubit quantum state $\rho$, we select $r \inrand \{0,1\}^{2n}$ and apply
\begin{equation}\label{eq:quantum-one-time-pad}
\rho \longmapsto P_r \rho P_r^\dagger\,,
\end{equation}
where $P_r$ denotes the element of the $n$-qubit Pauli group indexed by $r$. 

One disadvantage of the quantum one-time pad is that parties must share two bits of randomness for every qubit which they wish to transmit securely. In particular, one cannot securely exchange multiple messages with the same key. To address this issue, we must settle for computational security assumptions and use pseudorandomness to select $r$. A general encryption scheme for quantum states is then defined as follows.

\begin{definition}
A symmetric-key quantum encryption scheme is a triple of QPTs:
\begin{itemize}
\item (key generation) $\KeyGen : 1^n \longmapsto k \in \{0, 1\}^n$;
\item (encryption) $\Enc_k : \states (\mathcal H_m) \longrightarrow \states (\mathcal H_c)$;
\item (decryption) $\Dec_k : \states (\mathcal H_c) \longrightarrow \states (\mathcal H_m)$;
\end{itemize}
where $m$ and $c$ are polynomial functions of $n$, and the QPTs satisfy $\| \Dec_k \circ \Enc_k - \one_m \|_\diamond \leq \negl(n)$ for all $k \in \emph{\supp}\,\KeyGen(1^n)$.
\end{definition}

Public-key quantum encryption schemes are defined in an analogous manner. The encryption schemes we will need must produce ciphertexts which are computationally indistinguishable. In some cases, the ciphertexts will need to remain indistinguishable even to adversaries which possess oracle access to the encryption algorithm (and sometimes also even the decryption algorithm.) This security notion is captured by the following definition.

\begin{definition}\label{def:IND}
A symmetric-key quantum encryption scheme is IND-secure if for all QPTs $\algo A, \algo A'$,
$$
\left|\prob[ (\algo A' \circ \Enc_k \otimes \one_s \circ \algo A) \cdot 1^n = 1] -
\prob[ (\algo A' \circ \Xi_{\Enc_k \ket{0^m}\bra{0^m}} \otimes \one_s \circ \algo A) \cdot 1^n = 1] \right|
\leq \negl(n)\,,
$$ 
where $\Xi_\sigma: \rho \mapsto \sigma$ is the ``forgetful'' map, and $s$ is a polynomial function of $n$. If $\algo A$ and $\algo A'$ have oracle access to $\Enc_k$, then we say that the scheme is IND-CPA secure. If in addition $\algo A'$ has oracle access to $\Dec_k$, then we say that the scheme is IND-CCA1 secure.
\end{definition}

The two QPTs $\algo A$ and $\algo A'$ together model the adversary. The definition above captures the idea of a certain ``security game'' between an adversary and a challenger. The game proceeds in steps: (i.) the key is selected and the adversary receives access to the appropriate oracles, (ii.) after some computation, the adversary transmits the first part of a bipartite state $\rho_{ms}$ to a challenger, (iii.) the challenger either encrypts this or replaces it with the encryption of $\ket{0^m}\bra{0^m}$, and then returns the result to the adversary, and (iv.) the adversary must decide which choice the challenger made. The scheme is considered secure if the adversary can do no better than random guessing. As shown in \cite{ABGFSS15}, this definition is equivalent to a security notion called \emph{semantic security}; roughly speaking, this notion captures the idea that anyone that tries to compute anything about a plaintext gains no advantage by possessing its encryption. In addition, \expref{Definition}{def:IND} is equivalent to several natural variants, where e.g., the challenger chooses to encrypt one of two messages provided by the adversary, or where the game is played over multiple rounds. The latter guarantees security of transmitting multiple ciphertexts produced via encryption with the same key.

We now show how to use qPRFs to construct simple symmetric-key quantum encryption schemes that satisfy all of the above security conditions.

\begin{theorem}\label{thm:IND-CCA1}
If quantum-secure pseudorandom functions exist, then so do IND-CCA1-secure symmetric-key quantum encryption schemes.
\end{theorem}
\begin{proof}
Let $\{f_k\}$ be a qPRF. For simplicity we assume that each $f_k$ is a map from $\{0, 1\}^n$ to $\{0, 1\}^2n$. Recall that for $r \in \{0, 1\}^2n$, $P_r$ denotes the element of the $n$-qubit Pauli group indexed by $r$. Consider the following scheme:
\begin{itemize}
\item $\KeyGen(1^n)$: output $k \inrand \{0, 1\}^n$;
\item $\Enc_k(\rho)$: choose $r \inrand \{0, 1\}^n$; output $\ket{r}\bra{r} \otimes P_{f_k(r)} \rho P_{f_k(r)}^{\dagger}$;
\item $\Dec_k(\ket{r}\bra{r} \otimes \sigma)$: output  $P_{f_k(r)}^\dagger \rho P_{f_k(r)}$\,.
\end{itemize}
In the decryption algorithm, we may assume that the first register is always measured prior to decrypting. Correctness of the scheme is straightforward to check: decrypting with the same key and randomness simply undoes the Pauli operation.

We now sketch the proof that the scheme is IND-CCA1 secure; a complete proof will appear in \cite{ABGFSS15}. The key observation is that each query to the encryption oracle is no more useful than receiving a pair $(r, f_k(r))$ for $r \inrand \{0, 1\}^{2n}$, and that each decryption oracle is no more useful than receiving a pair $(r, f_k(r))$ for a string $r$ of the adversary's choice. Thus the adversary learns at most a polynomial number of values of $f_k$. Now, if $f_k$ is a perfectly random function, then these values are completely uncorrelated to the one used to encrypt the challenge. The scheme is thus secure simply by the information-theoretic security of the quantum one-time pad. On the other hand, if $f_k$ is a function in a qPRF, \expref{Definition}{def:quantum-secure-prf} guarantees oracle indistinguishability from perfectly random functions. It follows that, if $(\algo A, \algo A')$ can break the actual scheme, then by computational indistinguishability they would also break the perfect scheme, which is impossible.
\end{proof}

We emphasize that the above proof shows that, even in the case where the adversary chooses the randomness $r$ used by the $\Enc_k$ and $\Dec_k$ oracles, the scheme remains secure. Of course, the randomness for the challenge encryption must still be selected by the challenger. \ga{But do we actually need that *any* IND-CCA1 scheme is secure when adversaries choose randomness, as opposed to just this one?} Finally, by combining \expref{Theorem}{thm:qOWF-implies-qPRF} and \expref{Theorem}{thm:IND-CCA1}, we have the following fact.

\begin{theorem}\label{thm:qOWF-implies-qSKE}
If quantum-secure one-way functions exist, then so do IND-CCA1-secure symmetric-key quantum encryption schemes.
\end{theorem}

%%%%%%%%%%%%%%%%%%%%%%
\section{Quantum black-box obfuscation}\label{sec:black-box}
%%%%%%%%%%%%%%%%%%%%%%

\subsection{Definitions}
%%%%%%%%%%%%%%%%%%%%%%

We now define the notion of an interpreter, which is simply a quantum algorithm equipped with some additional data.

\begin{definition}
An \textbf{interpreter} is a polynomial-time uniform family of unitary quantum circuits $\mathcal J = \{J_{n, m}\}_{n, m \in \N}$, such that for every $n$ and $m$, $J_{n, m}$ has an $n$-qubit register $A$, an $m$-qubit register $B$, and an ancilla $C$ of size poly$(n, m)$. For every $n \in \N$ and every $m$-qubit state $\rho$, we define a superoperator on $A$ by
$$
\mathcal J_n^\rho : \sigma \mapsto \emph{Tr}_{BC}\bigl( J_{n, m}\bigl[ \sigma \otimes \rho \otimes \ket{0}\bra{0}_C \bigr]J_{n, m}^\dagger\bigr)\,.
$$
\end{definition}

\noindent In applications, we think of $\mathcal J$ as enabling an end-user to apply a superoperator to an input state $\sigma$ with the help of the $m$-qubit ``advice'' state $\rho$, presumably provided by some other party. We say that the state $\rho$ implements the operator $\mathcal J_n^\rho$. A simple example is given by universal circuits: in this case, $\rho$ is a classical description of a quantum circuit for implementing $\mathcal J_n^\rho$, and $J_{n, m}$ consists of a universal sequence of gates which are applied to the first register and controlled by the second register. While this is not explicitly required by the definition, all advice states in this work will be efficiently preparable.


We now wish to consider obfuscated advice. Given a (potentially non-unitary) quantum circuit $C$, let $U_C$ denote the superoperator implemented by $C$. We will frequently refer to ``quantum adversaries'' and ``quantum simulators.'' Both will mean a polynomial-time quantum algorithm which accepts a quantum state as input (along with a polynomial-size initialized ancilla) and outputs a classical bit. We will sometimes make use of quantum simulators which have oracle access to some unitary operator; such a simulator will be denoted by, e.g.,  $\mathcal S^U$. The quantum circuits of such a simulator are allowed to make use of a ``black box'' gate which applies $U$. Each use of a black box counts towards the length of the circuit, which must remain polynomial in the input size.
\begin{definition}
A \textbf{black-box quantum obfuscator} is a pair $(\mathcal J, \mathcal O)$ where $\mathcal J$ is an interpreter and $\mathcal O$ is a probabilistic-quantum algorithm which, on input an $n$-qubit quantum circuit $C$, outputs an $m$-qubit quantum state $\mathcal O(C)$ satisfying
\begin{enumerate}
\item (polynomial slowdown)  $m = \text{poly}(n, |C|)$;
\item (functional equivalence) there exists a negligible $\epsilon_1$ such that $\bigl\| \mathcal J_n^{\mathcal O(C)} - U_C \bigr\|_\diamond \leq \epsilon_1(n, |C|)$;
\item (virtual black-box) for every quantum adversary $\mathcal A$ there exists a quantum simulator $\mathcal S^{U_C}$ and a negligible $\epsilon_2$ such that
$$
\Bigl| \emph{Pr}[\mathcal A(\mathcal O(C)) = 1] - \emph{Pr}\bigl[\mathcal S^{U_C}\bigl(\ket{0}^{\otimes |C|}\bigr) = 1\bigr] \Bigr| \leq \epsilon_2(n, |C|)\,.
$$
\end{enumerate}
\end{definition}
\noindent We will select the functions $\epsilon_1, \epsilon_2$ later, to be the largest possible for which our impossibility proofs still work.

Note that allowing $\mathcal O$ to be probabilistic-quantum allows it to output different states $\mathcal O(C; r)$ depending on the choice of classical randomness $r$. Why is this different from just letting $\mathcal O$ be fully quantum? Suppose that we were to change the above definition to that effect, and consider the case where $C$ is used to flip a single bit. The obfuscator could then, with equal probability, output either a state which always outputs $1$ or a state which always outputs $0$. Because we combined this choice into a density matrix, the functional equivalence condition would technically be satisfied. On the other hand, the actual output state of the algorithm would \emph{never} satisfy functional equivalence -- a frustrating situation for the end-user, to say the least.

\noindent \ga{New work starts here. I begin with another attempt at a definition, this time without explicitly defining an interpreter.}

For shorthand, we will denote CPTP maps by, e.g., $\algo A ( \cdot )$, which is to mean the map $\rho \mapsto \algo A(\rho)$. We also use ``QPT'' as shorthand for quantum polynomial-time algorithm, and ``$\negl$'' as shorthand for some function which grows inverse-superpolynomially.

\begin{definition}
A \textbf{black-box quantum obfuscator} is a pair of QPTs $(\algo J, \algo O)$ such that whenever $C$ is an $n$-qubit quantum circuit, the output of $\algo O$ is an $m$-qubit state $\algo O(C)$ satisfying
\begin{enumerate}
\item (polynomial slowdown)  $m = \text{poly}(n, |C|)$;
\item (functional equivalence) $\bigl\| \algo J ( \algo O(C) \otimes \,\cdot\, ) - C \,\cdot\, C^\dagger \bigr\|_\diamond \leq \negl(n, |C|)$;
\item (virtual black-box) for every QPT adversary $\mathcal A$ there exists a QPT simulator $\mathcal S^{U_C}$ such that
$$
\Bigl| \emph{Pr}[\mathcal A(\mathcal O(C)) = 1] - \emph{Pr}\bigl[\mathcal S^{U_C}\bigl(\ket{0}^{\otimes |C|}\bigr) = 1\bigr] \Bigr| \leq \negl(n, |C|)\,.
$$
\end{enumerate}
\end{definition}

\noindent \ga{Here should discuss alternative definition (where obfuscator provides a state as well as a circuit to run), and prove that since we are only interested in existence, the two definitions are equivalent.}

\ga{Do we want to discuss inefficient obfuscators? I guess we can show that inefficient perfect indistinguishability obfuscators exist... and that these are black-box for any circuits that *do* have black-box obfuscations...}

\subsection{Applications}
%%%%%%%%%%%%%%%%%%%%%%

In this section, we motivate the study of quantum black-box obfuscation by giving a few example applications. Many of these are motivated by known classical applications of classical black-box obfuscators. Although our impossibility results will put some restrictions on these applications, they remain interesting. In fact, some of the applications (such as quantum-secure one-way functions) will be used in the impossibility proofs themselves.

\subsubsection{Quantum-secure one-way functions}
%%%

The first application shows that, if there exists a classical algorithm for obfuscating quantum computations, then quantum-secure one-way functions exist. By the results discussed in \expref{Section}{sec:encryption}, this also implies the existence of quantum-secure pseudorandom generators, quantum-secure pseudorandom functions, and IND-CCA1-secure symmetric-key quantum encryption schemes.

\begin{prop}
If there exists a classical probabilistic algorithm which is a quantum black-box obfuscator, then quantum-secure one-way functions exist.
\end{prop}
\begin{proof}
The proof is essentially the same as that of Lemma 3.8 in \cite{BGIRSVY12}. For all $a \in \{0, 1\}^n$ and $b \in \{0, 1\}$, we define 
$$
U_{a, b} : \ket{x,\, y} \longmapsto
\begin{cases}
\ket{a,\, y \oplus b} &\text{ if } x = a;\\
\ket{x,\, y} &\text{ otherwise}.
\end{cases}
$$
Define a function $f : \{0, 1\}^* \rightarrow \{0, 1\}^*$ by $f(a, b, r) = \algo O_r(U_{a, b})$ where $\algo O$ is the obfuscator\footnote{For simplicity of notation, we omit $\algo J$ and assume that $f(a, b, r) = \algo O_r(U_{a, b})$ is in fact a classical circuit for $U_{a, b}$.} as in the hypothesis, and $\algo O_r$ denotes the same algorithm, but with randomness coins initialized to $r$. Clearly, inverting $f$ requires computing $b$ from $\algo O_r(U_{a, b})$. Moreover, with only black-box access to $U_{a, b}$ (for uniformly random $a, b$) the probability of correctly outputing $b$ in polynomial time is at most $1/2 + \negl(n)$.  By the black-box property of $\mathcal O$, we then have
\begin{align*}
\prob_{a, b} [ A(f(a, b, r)) = b] 
&= \prob_{a, b} [ A(\mathcal O_r(a, b)) = b ]\\
&\leq \prob_{a, b} \left[ S^{U_{a, b}}(1^n) = b\right] + \negl(n)\\
&\leq \frac{1}{2} + \negl(n)\,,
\end{align*}
which completes the proof.
\end{proof}

We remark that the above proof fails if the obfuscator is a quantum algorithm---even if its output is itself classical. The issue is that one-way functions must be deterministic; while one can turn a classical probabilistic algorithm into a deterministic one by making the coins part of the input, this is not possible quantumly. We leave the problem of constructing cryptographically useful primitives from a fully quantum obfuscator (or even just from a quantum encryption scheme) as an interesting open question. 

\subsubsection{CPA-secure private-key quantum encryption}
%%%

Can we say anything about encryption of data if we know that \emph{quantum} algorithms for quantum black-box obfuscation exist? While we do not know how to extract one-way functions, we can nonetheless produce useful encryption schemes, as follows.

\begin{prop}
If quantum black-box obfuscators exist, then so do IND-CPA-secure symmetric-key quantum encryption schemes.
\end{prop}
\begin{proof}
Let $(\algo O, \algo J)$ be a quantum black-box obfuscator. We consider an adaptation of the unitary operator $U_{a, b}$ defined above, but now with Pauli group action instead of XOR, and with two $n$-bit registers:
$$
U'_{r, k} : \ket{x,\, y} \longmapsto
\begin{cases}
\ket{x,\, P_r^\dagger y} &\text{ if } x = k;\\
\ket{x,\, y} &\text{ otherwise},
\end{cases}
$$
Now consider the following scheme for encrypting $n$-qubit quantum states.
\begin{itemize}
\item $\KeyGen(1^n)$: output $k \inrand \{0, 1\}^n$;
\item $\Enc_{k}(\rho)$: choose $r \inrand \{0, 1\}^n$; output $P_r \rho P_r^\dagger \otimes \algo O(U_{r, k})$;
\item $\Dec_{k}(\sigma \otimes \tau)$: output  the second register of $\algo J(\tau \otimes \ket{k}\bra{k} \otimes \sigma)$.
\end{itemize}
To check correctness, we apply the functionality-preserving property of the obfuscator. A decryption of a valid encryption with the same key yields
\begin{align*}
\Dec_k (\Enc_k (\rho))  
&= \tr_1 \left[\algo J(\algo O(U_{r, k}) \otimes \ket{k}\bra{k} \otimes P_r \rho P_r^\dagger)\right] \\
&= \tr_1 \left[U_{r, k} (\ket{k}\bra{k} \otimes P_r \rho P_r^\dagger) U_{r, k}^\dagger\right] \\
&= \tr_1 \left[\ket{k}\bra{k} \otimes \rho \right] \\
& = \rho\,.
\end{align*}
as desired. IND-CPA security follows from the black-box property of the obfuscator, as follows. Let $\algo A$ be an adversary with access to the encryption oracle. Since the output of the encryption is a product state, $\algo A$ can be simulated by an adversary $\algo S$ that has only the first register of the ciphertext (i.e., $P_r \rho P_r^\dagger$) and black-box access to the unitary $U'_{r, k}$. It's then clear that $\algo S$ can only succeed in the challenge stage of \expref{Definition}{def:IND} by discovering the secret input for $U'_{r, k}$ or by guessing the response to the challenge. In any case, $\algo S$ (and hence also $\algo A$) succeeds with probability at most $1/2 + \negl(n)$.
\end{proof}

\subsubsection{Public-key encryption from private-key encryption}
%%%

As we now show, combining black-box obfuscation with one-way functions yields even stronger encryption functionality.

\begin{prop}\label{prop:PKE}
If quantum black-box obfuscators and quantum-secure one-way functions exist, then so do IND-CPA-secure public-key quantum encryption schemes.
\end{prop}
\begin{proof}
Under the hypothesis, \expref{Theorem}{thm:qOWF-implies-qSKE} implies the existence of IND-CCA1-secure symmetric-key encryption schemes for quantum states. Let $(\KeyGen, \Enc, \Dec)$ be such a scheme; for concreteness, we may take the scheme described in \expref{Theorem}{thm:IND-CCA1}. For $x \in \{0, 1\}^n$, let $\Enc_{(x)}$ denote the encryption circuit for key $x$; this is the circuit that accepts two input registers (one for randomness, and one for the plaintext) and outputs the ciphertext. Now define a public-key encryption scheme $(\KeyGen', \Enc', \Dec')$ as follows.
\begin{itemize}
\item $\KeyGen'(1^n)$: output $sk : = k \inrand \{0, 1\}^n$ (secret key) and $pk := \algo O\left(\Enc_{(sk)}\right)$ (public key);
\item $\Enc'_{pk}(\rho)$: choose $r \inrand \{0, 1\}^n$; output $pk( \ket{r}\bra{r} \otimes \rho)$;
\item $\Dec'_{sk}(\sigma)$: output  $\Dec_{sk}(\sigma)$\,.
\end{itemize}
The correctness of this scheme follows directly from the functionality-preserving property of $\algo O$ and the correctness of the private-key scheme. To prove IND-CPA security for the public-key scheme, we rely on the black-box property. It implies that any QPT adversary $\algo A$ with access to the public key can be simulated by a QPT $\algo S$ having only black-box access to $\Enc_{(sk)}$. The QPT $\algo S$, in turn, can be simulated by a QPT $\algo S'$ which has both decryption and encryption oracles for the private-key scheme $(\KeyGen, \Enc, \Dec)$. It may not be immediately obvious that the decryption oracle is necessary; this is the case because black-box access to $\Enc_{(sk)}$ enables $\algo S$ to select the randomness used for encryption, thus gaining the ability to evaluate pairs $(r, f_{sk}(r))$ where $f$ is the qPRF from the private-key scheme. 

Now we have that, if $\algo A$ can distinguish ciphertexts during the challenge, then so can $\algo S'$; since the ciphertexts themselves are the same for the public-key scheme and the private-key scheme, this contradicts the IND-CCA1 security of the private-key scheme.
\end{proof}

A few remarks are in order. First, in~\cite{ABGFSS15} it is shown that IND-CPA-secure public-key quantum encryption schemes exist under the assumption that quantum-secure trapdoor permutations exist. This is a stronger assumption than one-way functions. \expref{Proposition}{prop:PKE} can then be thought of as replacing this strengthening of assumptions with an obfuscator. In~\cite{BJ15} it is shown how to use quantum-secure classical public-key encryption to produce quantum public-key encryption (by encrypting the key for the quantum one-time pad); this amounts to the same assumption on primitives as in~\cite{ABGFSS15}. An important difference between~\cite{ABGFSS15, BJ15} and \expref{Proposition}{prop:PKE} is that the scheme from \expref{Proposition}{prop:PKE} may have public keys which are quantum states. Such schemes have not been considered before, and (due to no-cloning) would have significantly different features from their classical counterparts.

An interesting question is if there could be public-key encryption for classical data, but where the encryption procedure is performed by a quantum algorithm. While this question remains open, our impossibility results will show that this cannot be achieved in a generic way via \expref{Proposition}{prop:PKE}.

\subsubsection{(Quantum?) Fully homomorphic encryption encryption}
%%%

\ga{TODO: write this}

The idea: obfuscate the universal decrypt-gate-encrypt circuit and hand it to the server. Unfortunately, to make QFHE useful, this would have to be reusable. In fact, one might imagine a way for doing classical FHE using quantum obfuscation.

For now maybe concentrate only on the private-key setting?

\subsubsection{Quantum money}
%%%

\ga{TODO: write this}

The idea: obfuscate the verification circuit to turn private-key money into public-key money. Mention previous discussions of this idea by Mike and Stebila. Can this work even if the verification circuit turns out to be a state? Do we also need to obfuscate measurements if, e.g., the underlying private-key scheme is Wiesner's money?

\subsection{Impossibility results}
%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Impossibility of two-circuit obfuscation}
%%%

\ga{Bill, below are the new functions that I think we should use. Of course, you should check them!}

We will show two-circuit impossibility for the following unitary operators. Here $a$ and $b$ are chosen uniformly at random from $\{0,1\}^n$. The registers indexed by $x$ and $y$ are of size $n$. The register indexed by $C$ accepts a circuit description (under some fixed encoding), and needs to be able to handle inputs of size $|\algo O(C_{a, b})|$ where $C_{a, b}$ is a fixed, explicit poly$(n)$-size circuit for $U_{a, b}$. The second register of $V_{a, b}$ has size one.
\begin{align}\label{eq:pair-impossible}
U_{a, b} &: \ket{x,\, y} \longmapsto
\begin{cases}
\ket{x,\, y \oplus b} &\text{ if } x = a;\\
\ket{x,\, y} &\text{ otherwise}.
\end{cases}\\
V_{a, b} &: \ket{C,\, z} \longmapsto
\begin{cases}
\ket{x,\, z \oplus 1} &\text{ if } C(a) = b;\\
\ket{x,\, z} &\text{ otherwise}.
\end{cases}
\end{align}


~\\ \noindent \ga{the stuff below is old and needs to be redone.}

Classically, Barak et al. proved impossibility of generic black-box circuit obfuscation. We don't know how to prove the same fact for quantum circuits, but we can replicate the first step of their proof, namely the impossibility of black-box two-circuit obfuscation. We define a \textbf{black-box quantum two-circuit obfuscator} just as in the definition above, but with a different virtual black-box condition:

\begin{enumerate}
\setcounter{enumi}{2}
\item \emph{(two-circuit virtual black-box) for every pair of quantum circuits $C_1$ and $C_2$ and every quantum adversary $\mathcal A$ there exists a quantum simulator $\mathcal S^{U_{C_1}, U_{C_2}}$ and a negligible $\epsilon_2$ such that}
$$
\Bigl| \text{Pr}[\mathcal A(\mathcal O(C_1) \otimes \mathcal O(C_2)) = 1] - \text{Pr}\bigl[\mathcal S^{U_{C_1}, U_{C_2}}\bigl(\ket{0}^{\otimes |C_1| + |C_2|}\bigr) = 1\bigr] \Bigr| \leq \epsilon_2(n, |C|)\,.
$$
\end{enumerate}

\begin{theorem}
There exist pairs of unitaries $(U, V)$ such that no pair of quantum circuits is a two-circuit black-box obfuscation of $(U, V)$.
\end{theorem}
\begin{proof}
Let $(\mathcal O, \mathcal J)$ be an obfuscator. Choose a uniformly random $z \in \{0,1\}^n$. Define the following $(n+1)$-qubit unitaries:
$$
U_0 : \ket{x} \ket{y} \mapsto \ket{x} \ket{\delta_z(x) \oplus y}
\qquad \text{and} \qquad
U_1 : \ket{x} \ket{y} \mapsto \ket{x} \ket{y}\,,
$$
where $\delta_z : x \mapsto \delta_{xz}$ is the delta function at $z$. Using standard methods for building reversible circuits, we can specify a unitary poly$(n)$-length circuit $C_0$ that implements $U_0$. We also easily build a circuit $C_1$ which implements $U_1$ (i.e., the identity) such that $|C_0| = |C_1|$. We also define a circuit
$$
D_z : \ket{s} \ket{t} \mapsto \ket{s} \ket{f_z(s) \oplus t}
$$
on two registers: a register of size $m := |\mathcal O(C_0)| = |\mathcal O(C_1)|$, and a one-qubit register (as well as an ancilla we omit for simplicity.) The circuit $D_z$ initializes a portion of the ancilla to $\ket{z}\ket{0}$, and runs the interpreter circuit $J_{n+1, m}$ on $\ket{z}\ket{0}\ket{s}$. Finally, controlled by the second register of that computation, a CNOT is applied to $\ket{t}$. 

We now describe the adversary $\mathcal A$, who will essentially run the second state it receives on the first one. More precisely, on input $\mathcal O(C_j) \otimes \mathcal O(D_z)$ where $j \in \{0, 1\}$, the adversary will run the interpreter circuit $J_{m+1, |\mathcal O(D_z)|}$ on the input state $\mathcal O(C_j) \otimes \ket{0}\bra{0}_\text{out}$ with advice state $\mathcal O(D_z)$, and then measure the single-qubit ``out'' register. Prior to measurement, by the functional equivalence property of the obfuscator, the $m+1$-qubit output register of $J_{m+1, |\mathcal O(D_z)|}$ will be close (in trace distance) to the state $D_z(\mathcal O(C_j) \otimes \ket{0}\bra{0}_\text{out})$. Recall that $D_z$ uses its input (via the interpreter) as an advice state, runs it on $\ket{z}\ket{y}$, and then flips the ``out'' qubit iff the computation flipped $\ket{y}$. We conclude that the ``out'' qubit will be (nearly) in the state $\ket{j}$ at the end of the computation; this allows the adversary to detect if it was given the obfuscation of $C_0$ or the obfuscation of $C_1$.

Now suppose $\mathcal S^{U_{C_j}, U_{D_z}}$ is a simulator with black-box access to the unitary applied by $D_z$ and either $C_0$ or $C_1$. Since $\mathcal S$ is polynomial-time, it can only use $C_j$ a polynomial number of times. Without knowledge of $j$ or $z$, the success probability of $\mathcal S$ will be no better than exponentially close to $1/2$, while the success probability of $\mathcal A$ is exponentially close to $1$.
\end{proof}

Next, we should address the following question: if the obfuscated states are cloneable (or if we are allowed to ask the obfuscator for more than one copy), does one-circuit black-box obfuscation become impossible? In other words, can we change the above proof so that it works even when $C_0$ and $C_1$ are functionally equivalent? The natural function choice is one that, conditioned on a control wire, applies either $C_j$ or $D_z$ for random $z \in \{0, 1\}^n$ and random $j \in \{0, 1\}$. Does this work?

\subsubsection{Impossibility of obfuscation for cloneable outputs}
%%%

The main impossibility proof goes here. Outline:

\begin{itemize}
\item show how to paste the above pair of circuits to make a single circuit;
\item running circuit on itself computes something a simulator cannot;
\item but running circuits on themselves doesn't work, so we need to patch it with encryption...
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%
\section{Quantum indistinguishability obfuscation}\label{sec:indistinguishability}
%%%%%%%%%%%%%%%%%%%%%%

\subsection{Definitions}
%%%%%%%%%%%%%%%%%%%%%%

\begin{definition}\label{def:indistinguishability}
An \textbf{indistinguishability quantum obfuscator} is a pair $(\mathcal J, \mathcal O)$ where $\mathcal J$ is an interpreter and $\mathcal O$ is a quantum algorithm which on input an $n$-qubit quantum circuit $C$ outputs an $m$-qubit quantum state $\mathcal O(C)$, such that
\begin{enumerate}
\item (polynomial slowdown) $m = \text{poly}(n, |C|).$
\item (functional equivalence) there exists a negligible $\epsilon_1$ such that $\bigl\| \mathcal J_n^{\mathcal O(C)} - U_C \bigr\|_\diamond \leq \epsilon_1(n, |C|)$;
\item (indistinguishability) if a pair of circuits $C_1$ and $C_2$ satisfy $|C_1| = |C_2|$ and $\bigl\|U_{C_1} - U_{C_2}\bigr\|_\diamond \leq \epsilon_3(n, |C|)$, then $\bigl\|\mathcal O(C_1) - \mathcal O(C_2)\bigr\|_\emph{tr} \leq \epsilon_4(n, |C|)$.
\end{enumerate}
\end{definition}
\noindent As before, we will select $\epsilon_3$ and $\epsilon_4$ appropriately later. For a definition of best-possible obfuscation, we replace condition (3) above with the following:

\begin{enumerate}
\setcounter{enumi}{2}
\item \emph{(best-possible) for every pair of quantum circuits $C_1$ and $C_2$ that satisfy $|C_1| = |C_2|$ and $\bigl\|U_{C_1} - U_{C_2}\bigr\|_\diamond \leq \epsilon_3(n, |C|)$ and every quantum adversary $\mathcal A$, there exists a quantum simulator $\mathcal S$ and a negligible $\epsilon_2$ such that}
$$
\Bigl| \text{Pr}[\mathcal A(\mathcal O(C_1)) = 1] - \text{Pr}\bigl[\mathcal S\bigl(C_2\bigr) = 1\bigr] \Bigr| \leq \epsilon_2(n, |C|)\,.
$$
\end{enumerate}

The intuition behind the above definition is the following: any information $\mathcal A(\mathcal O(C_1))$ that is ``leaked'' by the obfuscation $\mathcal O(C_1)$ can actually be recovered from \emph{any} functionally equivalent, similarly-sized circuit $C_2$. In this sense, among all such circuits, the circuit $\mathcal O(C_1)$ is one that leaks the least. It's not hard to see that an efficient obfuscator satisfies the best-possible condition if and only if it satisfies the indistinguishability condition. This justifies \expref{Definition}{def:indistinguishability} as a natural choice.

\ga{To mention somewhere: GR07 observed that, if a circuit family \emph{has} a black-box obfuscation, then a computational indistinguishability obfuscator must compute it. So it's conceivable that many of the interesting black-box applications carry over to the quantum case. Of course, one could say that this is exactly why the recent classical results have worked.}


\subsection{Applications}
%%%%%%%%%%%%%%%%%%%%%%

\noindent {\bf Example: quantum witness encryption.} The classical idea of witness encryption is from a paper by Sahai, Garg and others, and the idea of solving it with obfuscation is from the big paper by Sahai et al. In the quantum case, we set up the problem as follows. Suppose Alice wishes to encrypt a quantum plaintext $\ket x$, but not to a particular key or for a particular person; instead, the encryption is tied to a challenge question, and anyone that can answer the question correctly can decrypt the plaintext. Alice outputs a ciphertext $F_\phi \ket x$ where $\phi$ is a quantum 3-SAT formula, such that there exists an efficient algorithm Eval with the property that Eval$(F_\phi\ket x, \ket y) = \ket x$ if $\ket y$ is a satisfying assignment for $\phi$. The security requirement is that if $\phi$ does not have a satisfying assignment, then the ensembles $F_\phi \ket x$ and $F_\phi \ket {x'}$ are quantum indistinguishable (formally, this now requires a definition of distinguishing \emph{quantum} ensembles) whenever $\ket x$ and $\ket{x'}$ are quantum states on the same number of qubits. Note that the definition says nothing about the case where $\phi$ is satisfiable but a satisfying assignment is not known. While this may seem counterintuitive, Sahai and Garg etc. are nonetheless able to construct various interesting encryption schemes (like public-key encryption and identity encryption) from witness encryption. 

The problem of quantum witness encryption can be solved using a quantum best-possible obfuscator $\mathcal O$, as follows. First, Alice selects a random Clifford (or Pauli) circuit $C$. She then writes down a quantum circuit $M_C$ which accepts two registers (and some ancillas), such that $M \ket z \ket y \ket 0 = \ket {C^{-1}z} \ket y \ket 0$ when $\ket y$ is a satisfying assignment for $\phi$, and $M \ket z \ket{y'} \ket 0 = \ket z \ket{y'} \ket 0$ for $\ket{y'}$ not a satisfying assignment for $\phi$. The ciphertext $F_\phi \ket x$ will consist of the pair $(C \ket x, \mathcal O(M_C))$. A recipient with a satisfying assignment $\ket y$ can decrypt by computing $\mathcal O(M_C) \ket {Cx} \ket y \ket 0$. On the other hand, if no satisfying assignment exists, then $M_C$ acts like the identity operator on every input. By the definition of best-possible, a quantum adversary can learn nothing more from $\mathcal O(M_C)$ than she could from the trivial circuit with no gates. Moreover, by the design property of Cliffords (or Paulis) the adversary also observes $\ket{Cx}$ to be a maximally mixed state.

\begin{itemize}
\item Stephen has a description of how to build the circuit $M_C$, and that should be added.
\item I guess the state $C \ket x$ and the circuit $M_C$ are correlated. Is this a problem? This probably has to be addressed by defining quantum indistinguishability of quantum ensembles, and then showing that quantum indistinguishability of the classical ensemble $\mathcal O(M_C)$ plus 2-design property on $C \ket{x}$ implies quantum indistinguishability of the quantum ensemble $(C \ket x, \mathcal O(M_C))$.
\item what does $M_C$ do if you feed in a state that has a little bit of projection into a satisfying assignment? I guess that, unless the size of the projection is $1/$poly, it's still indistinguishable from identity...
\item I have some ideas on why the above is exactly the right definition (e.g., weakening to $\phi$ being just a 3-SAT formula opens it up to being solved by classical obfuscation.) 
\end{itemize}

\subsection{Equivalence of indistinguishability and best-possible}
%%%%%%%%%%%%%%%%%%%%%%

\ga{some old stuff below should be removed, but most still applies}

In what follows, for the sake of simplicity we omit the perfect, statistical, and classical variants of the definitions; one can arrive at these versions simply by replacing quantum indistinguishability of the relevant ensembles to one of the other notions. We will always be obfuscating quantum circuits, so when the word ``quantum'' appears in front of ``obfuscator'', this refers to the type of indistinguishability. We say that two uniform quantum circuit families $\mathcal C'$ and $\mathcal C''$ are equivalent if they consist of functionally equivalent circuits of the same size; more precisely, for every $n$, $|\mathcal C'_n| = |\mathcal C''_n| = 1$ and $|C'_n| = |C''_n|$  and $U_{C'_n} = U_{C''_n}$.

\begin{itemize}
\item the exact-same-length condition seems too strong, but it does appear in GR too, along with a later comment about how it can be removed. I guess some care is needed.
\end{itemize}

\begin{definition} A classical probabilistic algorithm $\mathcal O$ that takes as input a quantum circuit $C$ and outputs another quantum circuit $\mathcal O(C)$ is a quantum {\bf best-possible obfuscator} for the family $\mathcal C$ if it satisfies properties (1) and (2) from Definition \ref{def:black-box}, as well as the following property:
\begin{enumerate}
\setcounter{enumi}{2}
\item for any learner (uniform quantum circuit family) $\mathcal L$, there is a simulator (uniform quantum circuit family) $\mathcal S$ and a negligible $\phi$ such that, for all uniform equivalent subfamilies $\mathcal C', \mathcal C''$ of $\mathcal C$, the two ensembles $\mathcal L(\mathcal O(\mathcal C'))$ and $\mathcal S(\mathcal C'')$ are quantumly indistinguishable.
\end{enumerate}
\end{definition}


\ga{some old stuff below}

\begin{definition} A classical probabilistic algorithm $\mathcal O$ that takes as input a quantum circuit $C$ and outputs another quantum circuit $\mathcal O(C)$ is a quantum {\bf indistinguishability obfuscator} for the family $\mathcal C$ if it satisfies properties (1) and (2) from Definition \ref{def:black-box}, as well as the following property:
\begin{enumerate}
\setcounter{enumi}{2}
\item for all uniform equivalent subfamilies $\mathcal C', \mathcal C''$ of $\mathcal C$, the two ensembles $\mathcal O(\mathcal C')$ and $\mathcal O(\mathcal C'')$ are quantumly indistinguishable.
\end{enumerate}
\end{definition}

\begin{itemize}
\item in all of the above, we could have considered obfuscating quantum states, or even using quantum algorithms to obfuscate classical descriptions of a quantum circuit. Why is this the ``right'' case (or at least an interesting one)?
\end{itemize}

With the definitions set up as above, many of the proofs of Goldwasser and Rothblum go through with little to no changes.

\begin{proposition} There exists an inefficient perfect indistinguishability obfuscator for all quantum circuits.
\end{proposition}
\begin{proof}
The obfuscator just picks the lexicographically first circuit which implements the same unitary as the given circuit. Looping through lexicographically ordered circuits can be done in PSPACE, and equivalence-checking can be done in QMA $\subset$ QIP = PSPACE too.
\end{proof}

\begin{itemize}
\item what's the smallest class that one can do this in?
\end{itemize}

\begin{proposition} If $\mathcal O$ is a best-possible quantum obfuscator for a circuit family $\mathcal C$, then it is also a quantum indistinguishability obfuscator for $\mathcal C$.
\end{proposition}
\begin{proof}
Let $\mathcal C'$ and $\mathcal C''$ be uniform equivalent subfamilies of $\mathcal C$, and let $\mathcal L$ be the trivial learner that simply implements the identity operator. By the best-possible property, there is a simulator $\mathcal S$ such that $\mathcal S(\mathcal C'')$ is quantum indistinguishable from $\mathcal L ( \mathcal O( \mathcal C')) = \mathcal O ( \mathcal C')$. By the same property, we also have that $\mathcal S(\mathcal C'')$ is quantum indistinguishable from $\mathcal L(\mathcal O (\mathcal C'')) = \mathcal O( \mathcal C'')$. By the transitivity property of indistinguishability, it follows that $\mathcal O(\mathcal C')$ is indistinguishable from $\mathcal O(\mathcal C'')$.
\end{proof}

\begin{proposition} If $\mathcal O$ is an efficient quantum indistinguishability obfuscator for a circuit family $\mathcal C$, then it is also an efficient quantum best-possible obfuscator for $\mathcal C$.
\end{proposition}
\begin{proof}
Let $\mathcal C'$ and $\mathcal C''$ be equivalent subfamilies of $\mathcal C$, and let $\mathcal L$ be a (quantum) learner whose output on $\mathcal C'$ is the ensemble $\mathcal L(\mathcal O (\mathcal C'))$. We define a (quantum) simulator by setting $\mathcal S = \mathcal L \circ \mathcal O$; its output on $\mathcal C''$ is then the ensemble $\mathcal L(\mathcal O(\mathcal C''))$. Since the ensembles $\mathcal O(\mathcal C')$ and $\mathcal O(\mathcal C'')$ are quantum indistinguishable, so are their images under $\mathcal L$.
\end{proof}

\subsection{Impossibility of statistical obfuscators}
%%%%%%%%%%%%%%%%%%%%%%

Recall the following computational problems and corresponding completeness results.

\begin{definition} \emph{$(a, b)$-Identity Check.}\\
\indent Input: an $n$-qubit quantum circuit $C$. \\
\indent Promise: $\min_\alpha \| U - e^{i \alpha} I \|$ is less than $a$ or greater than $b$.\\
\indent Output: YES in the former case and NO in the latter.
\end{definition}
\begin{theorem} 
The problem $(a, b)$-Identity Check is coQMA-complete if $b - a \leq 1/\emph{poly}(n)$. 
\end{theorem}
\noindent \textbf{Note:} apparently Rosgen showed that distinguishing mixed state computations is QIP-complete. Does this mean that we could have even stronger impossibility results if we asked for obfuscators that could obfuscate quantum circuits that included measurements?

Given an $m$-qubit state $\rho$, let $\tr_{(l, m)}[\rho]$ denote the result of tracing out qubits $l$ through $m$. Nothing is traced out if $l > m$.

\begin{definition} \emph{$(a, b)$-Quantum State Distinguishability}\\
\indent Input: $m$-qubit quantum circuits $C_1$ and $C_2$, positive integer $k \leq m$.\\
\indent Promise: let $\rho_i = \tr_{(k+1, m)}[C_i\ket{0^m}\bra{0^m}C_i^\dagger]$; then $\|\rho_0 - \rho_1\|_\emph{tr}$ is less than $a$ or greater than $b$.\\
\indent Output: YES in the former case and NO in the latter.
\end{definition}

\begin{theorem}
The problem $(a, b)$-Quantum State Distinguishability is QSZK-complete if $a < b^2$.
\end{theorem}

We will in fact only need the containment part of the above theorem.

\begin{theorem}
If there exists a polynomial-time indistinguishability quantum obfuscator, then coQMA is contained in QSZK.
\end{theorem}
\begin{proof}
(parameters should be checked.) We will actually show coQMA $\subset$ BQP$^{\text{QSZK}}$; since BQP is contained in QSZK, the result will follow. Let $a$ and $b$ satisfy $b-a \leq 1 / \text{poly}(n)$. We will solve $(a, b)$-Identity Check using a subroutine that solves $(\alpha, \beta)$-quantum state distinguishability. 

Let $C$ be the input, i.e., a classical description of an $n$-qubit quantum circuit. Create an identity circuit $D$ with an equal number of inputs as $C$, and of equal length to $C$. Let $O_C$ be a circuit that initializes a register with the classical state $\ket{C}$ containing the classical description of $C$, and applies the circuit of $\mathcal O$ which corresponds to the input length $|C|$. Likewise, let $O_D$ be be a circuit that initializes a register with the classical state $\ket{D}$ containing the classical description of $D$, and applies the circuit of $\mathcal O$ which corresponds to the input length $|D| = |C|$. Note that, after tracing out ancillas, the outputs of these circuits are given by
$$
\tr_\text{anc.} \bigl[O_C\ket{0}\bra{0}O_C^\dagger\bigr] = \mathcal O(C)
\qquad \text{and} \qquad
\tr_\text{anc.} \bigl[O_D\ket{0}\bra{0}O_D^\dagger\bigr] = \mathcal O(D)\,.
$$
Now apply the subroutine for solving quantum state distinguishability to the pair $(O_C, O_D)$. If it says ``close'', we output YES; otherwise we output NO. Let's show that this has solved $(a, b)$-identity-check. Note that the states $\mathcal O(C)$ and $\mathcal O(D)$ must have the same number of qubits, and denote that number by $m$.
\begin{itemize}
\item \textbf{completness.} In this case, the obfuscated states satisfy $\|\mathcal O(C) - \mathcal O(D)\|_\text{tr} \leq \alpha$.  By the definition of the induced trace norm, this implies that $\|\mathcal J_{\mathcal O(C)}^n - \mathcal J_{\mathcal O(D)}^n\|_\diamond \leq \alpha$. By functional equivalence for $C$ and $D$ and the triangle inequality, it follows that $\|U_C - U_D\|_\diamond = \|U_C - I\|_\diamond \leq \alpha$, as desired.

\item \textbf{soundness.} In this case, the obfuscated states satisfy $\|\mathcal O(C) - \mathcal O(D)\|_\text{tr} \geq \beta$. We claim that this implies $\|U_C - U_D\|_\diamond > b$. Suppose this is not the case, i.e., that these operators are in fact close; then by the indistinguishability property, it would follow that $\mathcal O(C)$ and $\mathcal O(D)$ are close as well, a contradiction.
\end{itemize}
The above amounts to a BQP$^\text{QSZK}$ protocol for a coQMA-hard problem, thus placing coQMA in QSZK.
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%
\section{Discussion}
%%%%%%%%%%%%%%%%%%%%%%

Open questions:
\begin{itemize}
\item can you achieve single-copy vbb obfuscation with quantum states?
\item can you achieve quantum circuit-to-circuit obfuscation under the comp. indistinguishability condition?
\item what happens if we think about obfuscating measurements, or CPTP circuits?
\end{itemize}

~\newpage~\newpage











%%%%%%%%%%%%%%%%%%%%%%
\section{[OLD NOTES]}
%%%%%%%%%%%%%%%%%%%%%%

\subsection{Preliminaries}
%%%%%%%%%%%%%%%%%%%%%%
Given a probability distribution $X$ on a finite set $S$ and an element $s \in S$, let $s \sim X$ denote the experiment of sampling $s$ according to the distribution $X$. For example, $\Pr_{s \sim X} [s \in S']$ denotes the probability that a sample of $X$ belongs to some subset $S' \subset S$. The total variation distance between two probability distributions $X$ and $Y$ taking values in $S$ is defined by
$$
|X - Y| = \frac{1}{2} \sum_{s \in S} \bigl|\Pr[X=s] - \Pr[Y=s]\bigr|\,.
$$
If $A$ and $B$ are random variables with the same range, the notation $|A-B|$ will mean the total variation distance between the distributions of $A$ and $B$.


We will often refer to circuits as deciding some problem, in the following sense. Let $\{C_n\}_{n \in \N}$ be a uniform family of classical probabilistic circuits. Fix $x \in \{0,1\}^n$, and let $C_n x$ denote the random variable determined by running $C_n$ on the input $x$ (with each remaining input bit set to either $0$ or to the outcome of a uniformly random coinflip) and reading out the value of the first output bit. If the input $x$ is selected according to some probability distribution $A$, then the acceptance probability is $\Pr_{x \sim A}[C_n x = 1]$. It is implicit that the probability is now taken over both the choice of $x$ and the coins of $C_n$.

We can also view quantum circuits in this way. In the remainder of these notes, ``quantum circuit'' will always mean ``unitary quantum circuit.'' Any measurements will be specified explicitly, and performed after the quantum circuit is applied. This is sufficient to describe arbitrary quantum computations (which in general may include many rounds of unitary operations, adapted measurements, and classical pre- and post-processing.) Set $\{C_n\}_{n \in \N}$ to be a uniform family of quantum circuits, and let $p(n)$ denote the number of qubits acted on by $C_n$. Given a quantum state $\ket \psi$ on $n$ qubits, we apply the circuit $C_n$ to the state $\ket \psi \ket{0}^{\otimes p(n)-n}$, and then measure the first qubit in the computational basis. This procedure can be described by a $\{0,1\}$-valued random variable, which we will denote by $M(C_n \ket \psi)$. Specifically, for $a \in \{0,1\}$,
$$
\Pr[M(C_n \ket \psi) = a] = \sum_{x \in \{0,1\}^{p(n)}\,:\,x_1 = a} \left| \bra{x} C_n \ket \psi \ket 0^{\otimes p(n)-n} \right|^2\,.
$$

\begin{itemize}
\item it is worthwhile to discuss here why there is no ``more powerful'' way to use circuit families to solve decision problems (e.g., by appealing to PromiseBQP/PromiseBPP-hardness).
\end{itemize}

A \emph{probability ensemble} $D$ is a sequence $\{D_n\}_{n \in \N}$ of bitstring-valued random variables, such that for some polynomial $\ell$, each $D_n$ takes values in $\{0,1\}^{\ell(n)}$. We may sometimes need such ensembles to be polynomial-time constructible, meaning that one can sample from $D$ via a uniform family of probabilistic circuits. Recall that a function $\phi: \N \rightarrow [0, \infty)$ is \emph{negligible} if it is smaller than inverse-polynomial in $n$.  We identify four distinct notions of indistinguishability of two probability ensembles $A$ and $B$:
\begin{enumerate}
\item \emph{perfectly indistinguishable}: $A_n = B_n$ for all sufficiently large $n$;
\item \emph{statistically indistinguishable}: there exists a negligible function $\phi$ such that $|A_n - B_n| \leq \phi(n)$ for all sufficiently large $n$;
\item \emph{quantumly indistinguishable}: there exists a negligible function $\phi$ such that, given any uniform family $\{C_n\}_{n \in \N}$ of quantum circuits, for all sufficiently large $n$ we have
$$
\left| \Pr_{x \sim A_n} [M(C_n \ket x) = 1] - \Pr_{x \sim B_n} [M(C_n \ket x) = 1] \right| \leq \phi(n)\,.
$$
\item \emph{classically indistinguishable}: there exists a negligible function $\phi$ such that, given any uniform family $\{C_n\}_{n \in \N}$ of classical probabilistic circuits, for all sufficiently large $n$ we have
$$
\left| \Pr_{x \sim A_n} [C_n x = 1] - \Pr_{x \sim B_n}[C_n x = 1] \right| \leq \phi(n)\,;
$$
\end{enumerate}

The quantum case can also be expressed naturally in terms of density operators. Let us write $M(C_n \rho)$ for the random variable corresponding to the same decision experiment as before, but now starting with a density operator $\rho$. Given a probability distribution $A$ on $\{0,1\}^n$, set
$$
\rho_A = \sum_{x \in \{0,1\}^n} \Pr[A = x] \ket x \bra x\,.
$$
The random variable $M(C_n \rho_A)$ then exactly captures the outcome of selecting a string at random according to $A$, and then running the decision experiment corresponding to $C_n$. In other words,
$$
\Pr_{x \sim A} [M(C_n \ket x) = a] = \Pr[M(C_n \rho_A) = a]\,.
$$

\begin{proposition} Indistinguishability of probability ensembles satisfies
$$
\text{perfect} \Rightarrow \text{statistical} \Rightarrow \text{quantum} \Rightarrow \text{classical}\,.
$$
\end{proposition}
\begin{proof}
Let $A$ and $B$ be probability ensembles. The first implication is immediate from the definition. For the second, recall the definition of trace norm $\|\rho\|_1 = \tr \sqrt{\rho \rho^\dagger}$, and note that the trace distance between the two relevant density operators is
$$
\left\| \rho_A - \rho_B \right\|_1 = 2 |A - B|\,.
$$
It's easy to check that the trace norm is unitarily invariant, so applying the same quantum circuit to both $\rho_A$ and $\rho_B$ does not affect the trace distance. The final measurement is just a projection to some subspace, and so the difference in the acceptance probabilities is bounded above by twice the trace distance. For the third implication, by standard arguments we can replace any classical circuit family that distinguishes two ensembles with a classical reversible circuit family that does the same. Reversible circuits are a special case of quantum circuits.
\end{proof}

\begin{itemize}
\item examples of why the implications are strict: (1) trivial, (2) large statistical difference but no quantum distinguisher (graph isomorphism?), and (3) quantum distinguisher but no classical distinguisher (factoring, or Bill's idea?).
\end{itemize}

By the triangle inequality, all four notions of indistinguishability are transitive, i.e. if $A$ is indistinguishable from $B$ and $B$ is indistinguishable from $C$, then $A$ is indistinguishable from $C$.  All four notions of indistinguishability are also closed under applying polynomial-time operations to both ensembles; the exception is that classically indistinguishable ensembles may become classically distinguishable after an efficient quantum algorithm is applied. 



\subsection{Black-box Quantum circuit obfuscation}
%%%%%%%%%%%%%%%%%%%%%%

Given a (not necessarily uniform) family of circuits $\mathcal C$, let $\mathcal C_n$ denote the subset of $\mathcal C$ consisting of all circuits that act on exactly $n$ qubits. If each $\mathcal C_n$ consists of one circuit only, then $C_n$ will refer to that unique circuit, and the expression $\mathcal C \ket x$ will mean $C_n \ket x$ where $n$ is the number of qubits of the state $\ket x$.

For a quantum circuit $C$, let $U_C$ denote the unitary operator implemented by $C$. The notation $S^C$ will stand for a quantum circuit $S$ which, in addition to a universal set of quantum gates, can also make use of an additional black-box gate which implements $U_C$. The black-box gate can be used as many times as needed, although each use does count toward the total length of $S^C$.

We are now ready to define a few different notions of quantum circuit obfuscation. Our definitions closely follow the classical ones in Goldwasser and Rothblum. 

\begin{definition}\label{def:black-box} A classical probabilistic algorithm $\mathcal O$ that takes as input a quantum circuit $C$ and outputs another quantum circuit $\mathcal O(C)$ is a quantum {\bf black-box obfuscator} for the circuit family $\mathcal C$ if it satisfies:
\begin{enumerate}
\item preserving functionality: there is a negligible function $\phi$ such that for any $n$ and any $C \in \mathcal C_n$, 
$$
\Pr[U_C \neq U_{\mathcal O(C)}] \leq \phi(n)\,.
$$
\item polynomial slowdown: there is a polynomial $p$ such that for any $C \in \mathcal C$, $|\mathcal O(C)| \leq p(|C|)$.
\item virtual black-box: For any adversary (uniform quantum circuit family) $\mathcal A$, there is a simulator (uniform quantum circuit family) $\mathcal S$ and a negligible $\phi$ such that
$$
\left| \Pr [M(\mathcal A\ket{\mathcal O(C)}) = 1] - \Pr[M(\mathcal S^C \ket{0}) = 1] \right| \leq \phi(n)
$$
for every $n$ and every $C \in \mathcal C_n$.
\end{enumerate}
\end{definition}

\begin{itemize}
\item in GR there aren't four versions of the last property -- just the computational one. Why?
\item we may later wish to relax the functionality-preserving condition, so that two unitaries are considered functionally equivalent so long as (say) there is no polynomial-length proof of their inequality. This would affect later definitions too.
\item are the classically not-black-box-obfuscatable functions also not quantum black-box obfuscatable?
\item if not, are there other examples of not-quantum-black-box-obfuscatable functions? In order for these examples to be interesting, I guess they shouldn't be ``learnable,'' i.e., you can't figure out exactly what they are with a polynomial number of black-box uses.
\item is there an example family of quantum circuits which *is* black-box obfuscatable?
\end{itemize}

\subsection{Best-possible}
%%%%%%%%%%%%%%%%%%%%%%

In what follows, for the sake of simplicity we omit the perfect, statistical, and classical variants of the definitions; one can arrive at these versions simply by replacing quantum indistinguishability of the relevant ensembles to one of the other notions. We will always be obfuscating quantum circuits, so when the word ``quantum'' appears in front of ``obfuscator'', this refers to the type of indistinguishability. We say that two uniform quantum circuit families $\mathcal C'$ and $\mathcal C''$ are equivalent if they consist of functionally equivalent circuits of the same size; more precisely, for every $n$, $|\mathcal C'_n| = |\mathcal C''_n| = 1$ and $|C'_n| = |C''_n|$  and $U_{C'_n} = U_{C''_n}$.

\begin{itemize}
\item the exact-same-length condition seems too strong, but it does appear in GR too, along with a later comment about how it can be removed. I guess some care is needed.
\end{itemize}

\begin{definition} A classical probabilistic algorithm $\mathcal O$ that takes as input a quantum circuit $C$ and outputs another quantum circuit $\mathcal O(C)$ is a quantum {\bf best-possible obfuscator} for the family $\mathcal C$ if it satisfies properties (1) and (2) from Definition \ref{def:black-box}, as well as the following property:
\begin{enumerate}
\setcounter{enumi}{2}
\item for any learner (uniform quantum circuit family) $\mathcal L$, there is a simulator (uniform quantum circuit family) $\mathcal S$ and a negligible $\phi$ such that, for all uniform equivalent subfamilies $\mathcal C', \mathcal C''$ of $\mathcal C$, the two ensembles $\mathcal L(\mathcal O(\mathcal C'))$ and $\mathcal S(\mathcal C'')$ are quantumly indistinguishable.
\end{enumerate}
\end{definition}

\noindent {\bf Example: quantum witness encryption.} The classical idea of witness encryption is from a paper by Sahai, Garg and others, and the idea of solving it with obfuscation is from the big paper by Sahai et al. In the quantum case, we set up the problem as follows. Suppose Alice wishes to encrypt a quantum plaintext $\ket x$, but not to a particular key or for a particular person; instead, the encryption is tied to a challenge question, and anyone that can answer the question correctly can decrypt the plaintext. Alice outputs a ciphertext $F_\phi \ket x$ where $\phi$ is a quantum 3-SAT formula, such that there exists an efficient algorithm Eval with the property that Eval$(F_\phi\ket x, \ket y) = \ket x$ if $\ket y$ is a satisfying assignment for $\phi$. The security requirement is that if $\phi$ does not have a satisfying assignment, then the ensembles $F_\phi \ket x$ and $F_\phi \ket {x'}$ are quantum indistinguishable (formally, this now requires a definition of distinguishing \emph{quantum} ensembles) whenever $\ket x$ and $\ket{x'}$ are quantum states on the same number of qubits. Note that the definition says nothing about the case where $\phi$ is satisfiable but a satisfying assignment is not known. While this may seem counterintuitive, Sahai and Garg etc. are nonetheless able to construct various interesting encryption schemes (like public-key encryption and identity encryption) from witness encryption. 

The problem of quantum witness encryption can be solved using a quantum best-possible obfuscator $\mathcal O$, as follows. First, Alice selects a random Clifford (or Pauli) circuit $C$. She then writes down a quantum circuit $M_C$ which accepts two registers (and some ancillas), such that $M \ket z \ket y \ket 0 = \ket {C^{-1}z} \ket y \ket 0$ when $\ket y$ is a satisfying assignment for $\phi$, and $M \ket z \ket{y'} \ket 0 = \ket z \ket{y'} \ket 0$ for $\ket{y'}$ not a satisfying assignment for $\phi$. The ciphertext $F_\phi \ket x$ will consist of the pair $(C \ket x, \mathcal O(M_C))$. A recipient with a satisfying assignment $\ket y$ can decrypt by computing $\mathcal O(M_C) \ket {Cx} \ket y \ket 0$. On the other hand, if no satisfying assignment exists, then $M_C$ acts like the identity operator on every input. By the definition of best-possible, a quantum adversary can learn nothing more from $\mathcal O(M_C)$ than she could from the trivial circuit with no gates. Moreover, by the design property of Cliffords (or Paulis) the adversary also observes $\ket{Cx}$ to be a maximally mixed state.

\begin{itemize}
\item Stephen has a description of how to build the circuit $M_C$, and that should be added.
\item I guess the state $C \ket x$ and the circuit $M_C$ are correlated. Is this a problem? This probably has to be addressed by defining quantum indistinguishability of quantum ensembles, and then showing that quantum indistinguishability of the classical ensemble $\mathcal O(M_C)$ plus 2-design property on $C \ket{x}$ implies quantum indistinguishability of the quantum ensemble $(C \ket x, \mathcal O(M_C))$.
\item what does $M_C$ do if you feed in a state that has a little bit of projection into a satisfying assignment? I guess that, unless the size of the projection is $1/$poly, it's still indistinguishable from identity...
\item I have some ideas on why the above is exactly the right definition (e.g., weakening to $\phi$ being just a 3-SAT formula opens it up to being solved by classical obfuscation.) 
\end{itemize}

\subsection{Indistinguishability}
%%%%%%%%%%%%%%%%%%%%%%

\begin{definition} A classical probabilistic algorithm $\mathcal O$ that takes as input a quantum circuit $C$ and outputs another quantum circuit $\mathcal O(C)$ is a quantum {\bf indistinguishability obfuscator} for the family $\mathcal C$ if it satisfies properties (1) and (2) from Definition \ref{def:black-box}, as well as the following property:
\begin{enumerate}
\setcounter{enumi}{2}
\item for all uniform equivalent subfamilies $\mathcal C', \mathcal C''$ of $\mathcal C$, the two ensembles $\mathcal O(\mathcal C')$ and $\mathcal O(\mathcal C'')$ are quantumly indistinguishable.
\end{enumerate}
\end{definition}

\begin{itemize}
\item in all of the above, we could have considered obfuscating quantum states, or even using quantum algorithms to obfuscate classical descriptions of a quantum circuit. Why is this the ``right'' case (or at least an interesting one)?
\end{itemize}

\subsection{Relationships between the definitions}
%%%%%%%%%%%%%%%%%%%%%%

With the definitions set up as above, many of the proofs of Goldwasser and Rothblum go through with little to no changes.

\begin{proposition} There exists an inefficient perfect indistinguishability obfuscator for all quantum circuits.
\end{proposition}
\begin{proof}
The obfuscator just picks the lexicographically first circuit which implements the same unitary as the given circuit. Looping through lexicographically ordered circuits can be done in PSPACE, and equivalence-checking can be done in QMA $\subset$ QIP = PSPACE too.
\end{proof}

\begin{itemize}
\item what's the smallest class that one can do this in?
\end{itemize}

\begin{proposition} If $\mathcal O$ is a best-possible quantum obfuscator for a circuit family $\mathcal C$, then it is also a quantum indistinguishability obfuscator for $\mathcal C$.
\end{proposition}
\begin{proof}
Let $\mathcal C'$ and $\mathcal C''$ be uniform equivalent subfamilies of $\mathcal C$, and let $\mathcal L$ be the trivial learner that simply implements the identity operator. By the best-possible property, there is a simulator $\mathcal S$ such that $\mathcal S(\mathcal C'')$ is quantum indistinguishable from $\mathcal L ( \mathcal O( \mathcal C')) = \mathcal O ( \mathcal C')$. By the same property, we also have that $\mathcal S(\mathcal C'')$ is quantum indistinguishable from $\mathcal L(\mathcal O (\mathcal C'')) = \mathcal O( \mathcal C'')$. By the transitivity property of indistinguishability, it follows that $\mathcal O(\mathcal C')$ is indistinguishable from $\mathcal O(\mathcal C'')$.
\end{proof}

\begin{proposition} If $\mathcal O$ is an efficient quantum indistinguishability obfuscator for a circuit family $\mathcal C$, then it is also an efficient quantum best-possible obfuscator for $\mathcal C$.
\end{proposition}
\begin{proof}
Let $\mathcal C'$ and $\mathcal C''$ be equivalent subfamilies of $\mathcal C$, and let $\mathcal L$ be a (quantum) learner whose output on $\mathcal C'$ is the ensemble $\mathcal L(\mathcal O (\mathcal C'))$. We define a (quantum) simulator by setting $\mathcal S = \mathcal L \circ \mathcal O$; its output on $\mathcal C''$ is then the ensemble $\mathcal L(\mathcal O(\mathcal C''))$. Since the ensembles $\mathcal O(\mathcal C')$ and $\mathcal O(\mathcal C'')$ are quantum indistinguishable, so are their images under $\mathcal L$.
\end{proof}

\subsection{Example: Clifford circuits}
%%%%%%%%%%%%%%%%%%%%%%

Recall that the single-qubit Pauli operators are defined by
$$
I =
\begin{pmatrix} 
1 & 0 \\
0 & 1 \\
\end{pmatrix}\,,
\qquad
X =
\begin{pmatrix} 
0 & 1 \\
1 & 0 \\
\end{pmatrix}\,,
\qquad
Y =
\begin{pmatrix} 
0 & -i \\
i & 0 \\
\end{pmatrix}\,,
\qquad
Z = 
\begin{pmatrix} 
1 & 0 \\
0 & -1 \\
\end{pmatrix}\,.
$$
Each Pauli operator is self-adjoint and unitary. A few useful relations are
$$
X^2 = Y^2 = Z^2 = I
\qquad
XY = -YX = iZ
\qquad
XZ = -ZX = -iY
\qquad 
YZ = -ZY = iX\,.
$$
From these relations, it's easy to see that the set of matrices $\alpha M$ where $\alpha \in \{\pm 1, \pm i\}$ and $M \in \{I, X, Y, Z\}$ forms a group under matrix multiplication. This group is generated by $\{X, Y, Z\}$ and $\{\pm 1, \pm  i\}$. In the $n$-qubit case, we first set
$$
X_j = I^{\otimes j-1} \otimes X \otimes I^{\otimes n-j}
$$
and likewise for $Y_j$ and $Z_j$. We define the $n$-qubit Pauli group $\mathcal P_n$ to be the group generated by $\{X_j, Y_j, Z_j : j = 1, \dots, n \}$  and $\{\pm 1, \pm i\}$.

The Clifford group on $n$ qubits is defined to be the normalizer of the Pauli group inside the unitary group, i.e.,
$$
\mathcal C_n = \{ U \in U(2^n) : U P U^\dagger \in \mathcal P_n \text{ for all } P \in \mathcal P_n\}\,.
$$
By direct computation on the Pauli generators, it's easy to check that the following gates are elements of $\mathcal C_n$ for any $n \geq 2$:
$$
H = \frac{1}{\sqrt{2}}
\begin{pmatrix} 
1 & 1 \\
1 & -1 \\
\end{pmatrix}\,,
\qquad
P = 
\begin{pmatrix} 
1 & 0 \\
0 & i \\
\end{pmatrix}\,,
\qquad
CNOT = 
\begin{pmatrix} 
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 0 & 1 \\
0 & 0 & 1 & 0
\end{pmatrix}\,.
$$
It is a theorem (see Gottesman's papers) that the above gates (when applied to arbitrary qubits or pairs of qubits) actually generate the entire Clifford group. A Clifford circuit is any circuit which is made up of gates from the above gate set. It is well-known that Clifford circuit computations can be efficiently simulated by a classical computer, but that adding any gate outside the Clifford group yields a quantum-universal set. In spite of their lack of computational power, Clifford circuits are quite relevant in quantum information, e.g., in quantum error correction and quantum cryptography.

In this section, we show how to put any Clifford circuit into a unique normal form. Something like this is already discussed in Gottesman's PI lectures. Selinger also provides a unique normal form (as well as generators and relations for $\mathcal C_n$) but he uses a different gate set. The approach below also seems more natural, as it's closely related to how Cliffords are usually discussed in the QI literature.

For us, a ``unique normal form'' is a map $f$ from Clifford circuits to Clifford circuits, such that \emph{(i.)} $C$ and $f(C)$ always implement the same unitary operator, and \emph{(ii.)} whenever $C_1$ and $C_2$ are circuits which implement the same unitary operator, $f(C_1)$ and $f(C_2)$ are identical as circuits. We will sketch out how this can be done using a polynomial-time classical algorithm. By definition, this immediately gives an indistinguishability obfuscator for Clifford circuits. 

Moreover, by a result of Richard Low, given a black box that implements a Clifford group element $U$, we can ``learn'' the action of $U$ on the Pauli generators in polynomial time. As our algorithm will make clear, knowing the action of $U$ on the generators suffices to produce the normal form. This means that any learner that has access to a normal-form Clifford circuit for $U$ can be simulated by a learner with black-box access to $U$. This obfuscation scheme thus also satisfies the conditions of black-box obfuscation.

Unfortunately, this obfuscation is in some sense trivial; while it is true that the precise form of the initial circuit is not learnable from the obfuscated circuit, it is nonetheless easy to learn the full functionality.

We can map each element of the $n$-qubit Pauli group to a $2n$-bit string by ignoring the phase and setting
$$
X_i \mapsto (\underbrace{0, \dots, 0}_{i-1}, 1, 0, \dots, 0)
\qquad \text{and} \qquad
Z_i \mapsto (\underbrace{0, \dots, 0}_{n+i-1}, 1, 0, \dots, 0)\,.
$$
By checking the relations on the generating set, one sees that this map yields an isomorphism
$$
f: \mathcal P_n / \{\pm 1, \pm I\} \rightarrow \Z_2^{2n}\,.
$$
It's also easy to compute how the conjugation action of a Clifford gate on a Pauli generator affects the corresponding binary string. Since conjugation is linear, this is described by a matrix. For example,
$$
H \mapsto
\begin{pmatrix}
0 & 1 \\
1 & 0 \\
\end{pmatrix}\,,
\qquad
P \mapsto
\begin{pmatrix}
1 & 0 \\
1 & 1 \\
\end{pmatrix}\,,
\qquad
CNOT \mapsto
\begin{pmatrix}
1 & 0 & 0 & 0\\
1 & 1 & 0 & 0\\
0 & 0 & 1 & 1\\
0 & 0 & 0 & 1\\
\end{pmatrix}\,.
$$
In general, for any fixed $n$, applying any of the above gates to a particular qubit (or pair of qubits for CNOT) will correspond to some easily computable $2n \times 2n$ binary matrix. Given a Clifford circuit $C$, we can multiply the matrices corresponding to each gate in $C$ to get a matrix $M(C)$. This matrix satisfies the property
$$
M(C) f(P) = f( M (CPC^\dagger))
$$
for every Pauli $P \in \mathcal P_n$. In fact, it is also the case that $M(C_1) = M(C_2)$ whenever $C_1, C_2$ are two Clifford circuits that implement the same element of the Clifford group. This follows from the isomorphism
$$
\mathcal C_n' \cong \opn{Sp}(2n, \F_2)\,,
$$
where $\mathcal C_n'$ denotes $\mathcal C_n$ modulo $\mathcal P_n$ and arbitrary phases, and $\opn{Sp}(2n, \F_2)$ denotes the group of $2n \times 2n$ symplectic matrices over $\F_2$. Why symplectic? Well, because Clifford elements preserve both commutation and anti-commutation of Pauli group elements, and whether two Pauli group elements commute or anti-commute is captured by a symplectic form of their corresponding binary strings:
$$
PQ = (-1)^{\omega(f(P), f(Q))}QP
$$
where
$$
\omega(x, y) = (x_1, \dots, x_n | y_{n+1}, \dots, y_{2n}) + (y_1, \dots, y_n |  x_{n+1}, \dots, x_{2n})
$$
and $(a | b)$ denotes the dot product modulo $2$.

It now remains to produce a unique Clifford circuit from $M(C)$, and append the right element of $\mathcal P_n.$ The former is done through a row reduction procedure. The key observation is that row reduction operations correspond to left-multiplication by matrices corresponding to gates. Once we have row-reduced $M(C)$ to the identity, we then invert the sequence of gates we applied to output a circuit $C'$. We then know that
$$
C^{-1} C' = P
$$
for some $P \in \mathcal P_n$. By applying each gate of $CC'$ to the Pauli generators, we can compute $P$ and append its inverse to $C'$. This constitutes a unique circuit which is equivalent to $C$ up to overall phases.

\begin{itemize}
\item the above is clearly just a sketch, which we can flesh out if we decide this is really important stuff.
\end{itemize}

\paragraph{Why is this uninteresting}

Note that any canonical form obfuscator is not, in general, a black-box obfuscator. A learner which is given the canonical form of a circuit can, in general, learn something that a learner with only black-box access cannot: namely, the canonical form itself! It's useful here to think about what such an obfuscator does on a family of circuits which are \emph{already} in canonical form.

Now suppose all of the functions computed by the relevant class of circuits are black-box learnable, in the sense that there is an efficient algorithm which can use black-box access to a function $f$ to output a description of any circuit (and hence also the canonical circuit) for computing $f$. Strictly speaking, the canonical-form obfuscator is now also a black-box obfuscator. But now again consider a uniform family of circuits which are already in canonical form. In this case, black-box access can be used to recover the entire original circuit perfectly. This should mean that, in an intuitive sense, obfuscation is completely impossible for this circuit family. This explains why our definitions (as well as the classical ones) are meaningless when we talk about efficiently learnable functions.






\bibliography{QuantumCrypto}






\end{document}
