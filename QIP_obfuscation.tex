\documentclass[11pt]{article}

\input{Qcircuit}
\usepackage{color}
\usepackage{amsmath,amsthm,amsbsy,amssymb,dsfont}
\usepackage{mathtools}
\usepackage[colorlinks=true,urlcolor=webblue,linkcolor=webgreen,filecolor=webblue,citecolor=webgreen,pdfpagemode=UseOutlines,pdfstartview=FitH,pdfpagelayout=OneColumn,bookmarks=true]{hyperref}
\usepackage{fullpage}
\usepackage{doi}
\usepackage[numbers]{natbib}
\usepackage{microtype}
\usepackage{xspace}
\usepackage{tikz}
\usepackage{bigints}
\usepackage{mathptmx}
\usepackage{palatino}
\usepackage{eucal}

\hypersetup{pdfauthor={Gorjan Alagic}}

\definecolor{webgreen}{rgb}{0,.5,0}
\definecolor{webblue}{rgb}{0,0,.5}

\DeclareMathOperator{\tr}{Tr}
\DeclareMathOperator*{\Exp}{\mathbb{E}}

\numberwithin{equation}{section}

\newtheorem{theorem}{Theorem}
\newtheorem{prop}{Proposition}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{conjecture}{Conjecture}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}{Definition}
\newtheorem{question}{Question}

%% Define a satisfactory mathbb 1.
\newcommand{\one}{\mathds 1}
\renewcommand{\vec}[1]{\mathbf{#1}}
\newcommand{\D}{\mathsf{D}}
\DeclareMathOperator{\Ind}{Ind}
\DeclareMathOperator{\End}{End}
\newcommand{\op}{\operatorname{op}}
\newcommand{\opn}{\operatorname}
\newcommand{\inter}{\mathfrak{I}}
\newcommand{\eqdef}{\triangleq}
\newcommand{\E}{\mathbb{E}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\U}{\textsf{U}}
\newcommand{\outerprod}[2]{|#1\rangle\langle #2|}
\newcommand{\innerprod}[2]{\langle #1, #2\rangle}
%\newcommand{\ket}[1]{|#1\rangle}
%\newcommand{\bra}[1]{\langle #1|}
\newcommand{\Hom}{\operatorname{Hom}}
\newcommand{\GL}{\textsf{GL}}
\newcommand{\SU}{\textsf{SU}}


\newcommand{\expref}[2]{\texorpdfstring{\hyperref[#2]{#1~\ref{#2}}}{#1~\ref{#2}}}
\newcommand{\expreft}[2]{\texorpdfstring{\hyperref[#2]{#1}}{#1}}

\newcommand{\revise}[1]{}
\renewcommand{\vec}[1]{\mathbf{#1}}

\newcommand{\band}[1]{\mathcal{#1}}
\newcommand{\error}{\varepsilon}
\newcommand{\recon}{R}
\newcommand{\idim}{\dim_{\opn{I}}}

%%% added by GA  Sept 2015
\newcommand{\algo}{\mathcal}
\newcommand{\negl}{\opn{negl}}
\newcommand{\KeyGen}{\ensuremath{\mathsf{KeyGen}}\xspace}
\newcommand{\Enc}{\ensuremath{\mathsf{Enc}}\xspace}
\newcommand{\Dec}{\ensuremath{\mathsf{Dec}}\xspace}
\newcommand{\Homorcl}{\ensuremath{\mathsf{Hom}}\xspace}
\newcommand{\Mint}{\ensuremath{\mathsf{Mint}}\xspace}
\newcommand{\Verify}{\ensuremath{\mathsf{Verify}}\xspace}
\newcommand{\inrand}{\in_R} 
\newcommand{\prob}{\opn{Pr}}
\newcommand{\states}{\mathfrak D}
\newcommand\supp{\textbf{supp}}
\newcommand\Eval{\ensuremath{\mathsf{Eval}}\xspace}
%%%

\newcommand{\ga}[1]{{ \textcolor{purple}{(Gorjan:  #1)}}{}}
\newcommand{\wf}[1]{{ \textcolor{orange}{(Bill:  #1)}}{}}

\bibliographystyle{plainnat}
\begin{document}


\title{Quantum obfuscation}
\author{Gorjan Alagic and Bill Fefferman}
\maketitle
\abstract{Encryption of data is fundamental to secure communication in the modern world. Beyond encryption of data lies \emph{obfuscation}, i.e., encryption of functionality. It has been known since 2001 that the most powerful means of obfuscating classical programs, so-called ``black-box obfuscation,'' is provably impossible. Several recent results have yielded classical candidate schemes that satisfy a definition weaker than black-box, and yet still have a number of applications.

In this work, we initialize the rigorous study of obfuscating programs \emph{via quantum-mechanical means.} In its most powerful ``virtual black-box'' instantiation, a quantum obfuscator would turn a description of a quantum program $f$ into a quantum state $\rho_f$, such that anyone in possession of $\rho_f$ can repeatedly evaluate $f$ on inputs of their choice, but never learn \emph{anything else} about the original program. We formalize this notion of obfuscation, and prove an impossibility result: such obfuscation is only possible in a setting where the adversary never has access to multiple obfuscations (of either the same program, or of different programs.) Nonetheless, we show that even in this remaining setting, some applications of obfuscations remain possible. These include CPA-secure quantum encryption, quantum fully-homomorphic encryption, and quantum money. 

We also define quantum versions of indistinguishability obfuscation and best-possible obfuscation. We then show that these notions are equivalent, and that their perfect and statistical variants are impossible to achieve. The situation is thus analogous to the classical case, where only computational indistinguishability obfuscation survives; such obfuscators would also have a novel application: witness encryption for QMA.

%%%%%%%%%%%%%%%%%%%%%%
\subsection*{1. Introduction}\label{sec:intro}
%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Obfuscation.} Obfuscation, i.e., the ability to encrypt functionality, is arguably the most powerful cryptographic ability that may yet be possible. Obfuscation implies (with some caveats) the ability to perform almost any other cryptographic task imaginable, including fully homomorphic encryption. To understand obfuscation, it is useful to think about an obvious application: protecting intellectual property in software. In this setting, a software developer wishes to distribute their software to end users without revealing the trade secrets in the code. In order to accomplish this, the software program is passed through an \emph{obfuscator} algorithm, which satisfies three core properties:
\begin{enumerate}\label{def:obf-informal}
\item \emph{functional equivalence:} input/output functionality does not change;
\item \emph{polynomial slowdown:} if the input program is efficient, then the output program is efficient;
\item \emph{obfuscation:} the code of the output program is ``hard to understand.''
\end{enumerate}
The last condition can be formulated rigorously in a number of ways. One possibility is the so-called ``virtual black-box'' condition, which says that the obfuscated program is no more useful than an impenetrable box which simply accepts inputs and produces outputs. While this condition appears to be too strong in the classical world, there are other formulations as well, with varying levels of strength and usefulness.

\paragraph{Classical status.} The first major result in classical obfuscation was the 2001 proof by Barak et al. that virtual black-box obfuscation is impossible~\cite{BGIRSVY01, BGIRSVY12}. They also showed that some of the most sought-after applications of black-box obfuscation are impossible. For instance, they showed that private-key encryption schemes cannot be transformed to public-key ones by obfuscating the encryption circuits in a generic manner.

An important step in formulating alternative notions of obfuscation was taken by Goldwasser and Rothblum; they defined \emph{indistinguishability obfuscation} and \emph{best-possible obfuscation}~\cite{GR07}. Under indistinguishability, it is required that the obfuscator maps functionally-equivalent circuits to indistinguishable distributions. Under best-possible, the obfuscator maps any circuit to a circuit from which the end user can ``learn the least.'' Both definitions have a perfect, statistical, and computational variant. Goldwasser and Rothblum proved that the two definitions are equivalent, and that the perfect and statistical versions are impossible (unless the PH collapses)~\cite{GR07}. This left one possibility: computational indistinguishability obfuscation. 

In 2013, in a breakthrough result, Garg et al. proposed a convincing candidate for computational indistinguishability obfuscation~\cite{GGHRSW13} based on the hardness of a certain problem in multilinear maps. Around the same time, another breakthrough by Sahai and Waters showed how to use a computational indistinguishability obfuscator to achieve a wide-range of applications, via a new ``punctured programs'' technique~\cite{SW14}. Sahai and Waters suggested that the applications were so wide-ranging that indistinguishability obfuscation might become a ``'central hub' for cryptography''~\cite{SW14}. These two breakthroughs were followed by a flurry of new activity in the area, including several new proposals and applications~\cite{BGKPS14, BCCGKPR14, BZ14, BR14, GGHW14, HSW14}. Unfortunately, the quantum security of the underlying hardness assumptions has recently been put into doubt~\cite{Pei15}.

\paragraph{Quantum status.} Quantum obfuscation is essentially an unexplored topic, and the present work appears to be the first rigorous treatment of the foundational questions. The question of whether quantum obfuscation is possible was posed as one of Scott Aaronson's ``semi-grand challenges'' for quantum computation~\cite{Aar05}. Since so little work on quantum obfuscation has appeared, we briefly discuss some related results. In~\cite{Aar09}, Aaronson proposed a \emph{complexity-theoretic no-cloning theorem}; he also claimed that an oracle exists relative to which ``software copy-protection'' is possible. Unfortunately, a full version of~\cite{Aar09} with proofs never appeared, although the complexity-theoretic no-cloning theorem was eventually proved in a paper on quantum money~\cite{AC12}. In related work, Mosca and Stebila proposed a black-box quantum money scheme, and suggested the possibility of using a quantum circuit obfuscator in place of the black box~\cite{MS10}. More recently, Alagic, Jeffery and Jordan proposed obfuscators for both classical (reversible) circuits and quantum circuits, based on ideas from topological quantum computation~\cite{ASS14}. The proposed obfuscator satisfies indistinguishability for a restricted set of circuit equivalences; its usefulness is unclear at this time.

%%%%%%%%%%%%%%%%%%%%%%
\subsection*{2. Our results}\label{sec:intro}
%%%%%%%%%%%%%%%%%%%%%%

We now summarize our contributions; details are explained in the full technical version. In what follows, algorithms will be called PT, PPT, or QPT; these mean (respectively) classical deterministic poly-time, probabilistic poly-time, and quantum poly-time. For a quantum circuit $C$, we denote the corresponding unitary operator by $U_C$. Functions which decay faster than any inverse-polynomial are denoted $\negl(\cdot)$.

\paragraph{Quantum black-box obfuscation.} 
%%%%

\begin{definition}\label{def:vbb-obfuscator}
A \textbf{black-box quantum obfuscator} is a pair of QPTs $(\algo J, \algo O)$ such that for any $n$-qubit quantum circuit $C$, the state\footnote{The poly-slowdown property now asks that $\mathcal O(C)$ is poly$(n)$-qubit; this is ensured by $\algo O$ being QPT.} $\mathcal O(C)$ satisfies:
\begin{enumerate}
\item (functional equivalence) $\bigl\| \algo J ( \algo O(C) \otimes \rho ) - U_C \rho U_C^\dagger \bigr\|_\emph{tr} \leq \negl(n)$ for all states $\rho$;
\item (virtual black-box) for every QPT $\mathcal A$ there exists a QPT $\mathcal S^{U_C}$ such that
$$
\Bigl| \emph{Pr}\bigl[\mathcal A(\mathcal O(C)) = 1\bigr] - \emph{Pr}\bigl[\mathcal S^{U_C}\bigl(\ket{0^n}\bigr) = 1\bigr] \Bigr| \leq \negl(n)\,.
$$
\end{enumerate}
\end{definition}
\noindent We remark that $\algo O(C)$ can be a classical or quantum state; we can also extend $C$ to cover non-unitary circuits (e.g., by including measurements.) Our first result places significant restrictions on quantum black-box obfuscators.

\begin{theorem}\label{thm:main}
Black-box quantum obfuscation is impossible\footnote{Depending on the particulars, we may need to assume the existence of quantum-secure one-way functions.} for pairs of circuits: any adversary with access to two outputs of the obfuscator (even on the same input) can violate the virtual black-box condition.
\end{theorem}

\noindent This result is a quantum generalization of the main result of Barak et al.~\cite{BGIRSVY01}. To prove our theorem, we give an explicit distribution of quantum circuit ensembles which cannot be obfuscated. The main technical obstacle in the proof is to show that the quantum states output by the obfuscator can be ``executed on one another,'' without revealing certain secret information to simulators having only black-box access to the original circuits. A crucial ingredient in overcoming this obstacle is a notion of \emph{chosen-ciphertext-secure quantum encryption.} To achieve this, we show the following.

\begin{theorem}\label{thm:cca}
If quantum-secure one-way functions (qOWF) exist, then so do IND-CCA1-secure symmetric-key quantum encryption schemes (qSKE).
\end{theorem}

\noindent The above requires several new definitions (e.g., IND-CCA1 for quantum encryption) which we also provide. A complete treatment of the subject of quantum encryption with computational assumptions will soon appear in a joint work~\cite{ABFGSS15}.

In addition, we provide several applications of quantum black-box obfuscation, which are still feasible (in some form) in spite of \expref{Theorem}{thm:main}. They are briefly outlined as follows.
\begin{enumerate}
\item \textbf{IND-CPA-secure encryption.} Crucially, this demands only a quantum black-box obfuscator, but \emph{not} one-way functions.
\item \textbf{qOWF imply IND-CPA public-key homomorphic encryption.} Start with qSKE via \expref{Theorem}{thm:cca}; public keys are obfuscations of encrypt circuits; evaluation keys are obfuscations of a universal decrypt-compute-encrypt circuit. Trapdoor permutations are not required.
\item \textbf{Public-key quantum money}. This was proposed by Mosca and Stebila~\cite{MS10}, using a result of Aaronson and Christiano~\cite{Aar09, AC12}. As we show, a certain adaptation survives \expref{Theorem}{thm:main}.
\end{enumerate}
\noindent We emphasize that applications 1 and 2 also work for achieving \emph{classical functionality} from a quantum obfuscator; however, they use quantum ciphertexts and quantum keys---another approach not considered before.

\paragraph{Quantum indistinguishability obfuscation.}
%%%%

Following the classical approach of Goldwasser and Rothblum~\cite{GR07}, we define a version of obfuscation which guarantees indistinguishability of obfuscator outputs on functionally equivalent inputs.
\begin{definition}\label{def:indistinguishability}
A \textbf{quantum indistinguishability obfuscator} is a pair of QPTs $(\algo J, \algo O)$ satisfying
\begin{enumerate}
\item (functional equivalence) $\bigl\| \algo J ( \algo O(C) \otimes \rho ) - U_C \rho U_C^\dagger \bigr\|_\emph{tr} \leq \negl(n)$ for all states $\rho$;
\item (indistinguishability) if $\|U_{C_1} - U_{C_2}\| \leq \negl(n)$, then $\|\mathcal O(C_1) - \mathcal O(C_2)\|_{*} \leq \negl(n)$.
\end{enumerate}
\end{definition}
\noindent There are three variants, depending on the nature of the norm $\| \cdot \|_{*}$: perfect, statistical, and computational (against QPTs) indistinguishability. We can replace the second condition with the following, to get a notion of \emph{quantum best-possible obfuscation.}
\begin{enumerate}
\setcounter{enumi}{1}
\item \emph{(best-possible) if $\|U_{C_1} - U_{C_2}\| \leq \negl(n)$ then for all QPT $\mathcal A$ there exists a QPT $\mathcal S$ such that}
$\| \mathcal A(\mathcal O(C_1)) - \mathcal S(C_2) \|_{*} \leq \negl(n)$.
\end{enumerate}
\noindent We then prove the following equivalence.

\begin{theorem}
A QPT is an indistinguishability obfuscator if and only if it is a best-possible obfuscator.
\end{theorem}

\noindent We also show that these definitions are only reasonable when the distinguishability is only guaranteed against computationally bounded (quantum) adversaries.

\begin{theorem}
If quantum statistical-indistinguishability obfuscators exist, then coQMA $\subseteq$ QSZK.
\end{theorem}

This leaves the indistinguishability approach to quantum obfuscation in a state of affairs similar to the classical world: computational obfuscation is the only surviving candidate. We end by showing that even such obfuscators would have an interesting application, namely quantum witness encryption for QMA. Witness encryption for a QMA language $L$ provides for encryption of a plaintext $x$ to a potential instance $l$. The security guarantee is that (i.) if $l \in L$, then any valid witness allows for decryption of $x$, and (ii.) if $l \notin L$, then encryptions of different plaintexts are computationally indistinguishable. Classical witness encryption is known to have numerous applications~\cite{GGSW13}. We show the following.
\begin{theorem}
If quantum computational-indistinguishability obfuscators exist, then so do witness encryption schemes for QMA.
\end{theorem}

\noindent We conjecture that many of the other recently discovered classical applications also have interesting quantum analogues or extensions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliography{QuantumCrypto}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}


